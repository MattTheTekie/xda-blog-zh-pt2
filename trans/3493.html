<html>
<head>
<title>In-Depth Capitulation of Why SD801 Devices Are Excluded from Nougat</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>深入投降为什么SD801设备被排除在牛轧糖</h1>
<blockquote>原文：<a href="https://www.xda-developers.com/in-depth-capitulation-of-why-msm8974-devices-are-excluded-from-nougat/#0001-01-01">https://www.xda-developers.com/in-depth-capitulation-of-why-msm8974-devices-are-excluded-from-nougat/#0001-01-01</a></blockquote><div><div class="content-block-regular">
<p><em>更新以反映Android 7.0的非此即彼Vulkan或OpenGL ES 3.1要求</em></p>

  
<p/><p>最近，有很多关于版本更新、厂商和芯片组制造商之间的互动以及这对设备发展意味着什么的文章。为什么这种情况会在本周出现？</p>

<p>本周有消息称，备受尊敬的Nexus 5将不会获得Android 7.0(牛轧糖)的更新，高通宣布将不会在7.0上提供对MSM8974(通常称为骁龙801)的支持。本文是与XDA公认的开发者<a href="http://forum.xda-developers.com/member.php?u=1588190"> bumble-bee合作撰写的。</a></p>

<p>这个话题吸引了许多新闻网站的关注，但是许多人忽略了幕后真正发生的事情的细微差别。本文将利用我们在OEM官方固件更新方面的经验，进一步解释软件更新的工作原理。我们将带您了解幕后发生的事情(以及原因)，以及为什么您可能无法在手机上安装最新的软件。</p>

<h1>上游更新</h1>
<p>Android固件更新的第一步是上游更新。这是谷歌内部的工作。与“开放的工作流程”不同，Android是使用封闭的工作流程开发的，每年左右，当一个新的版本发布时，源代码就会被扔到墙上。最初，谷歌表示这是为了防止在早期事物快速发展时运行前沿版本的人产生碎片，但他们似乎一直保持着这一政策。</p>

<p>在某个时间点，通常是在公开发布更新之前(尽管最近推出了公开测试版，但这些时间范围正在发生变化)，<strong>OEM将会知道即将到来的更新</strong>。然后，他们将在最后更新的第二个时间点收到源代码(在过去，有时会比发布早一点，尽管我们也知道没有提前发布的情况)。</p>

<p>上游AOSP储存库仅包含对有限数量的设备的设备支持。这些通常是你的Nexus设备。然而，很快就会清楚的原因是，值得注意的是，谷歌并没有完全控制这些设备的硬件；这些设备由OEM制造，OEM将从芯片组制造商那里购买片上系统(SoC)。</p>

<h1>芯片组制造商</h1>
<p>一旦源代码发布，OEM的固件团队将(象征性地)坐下来休息。主要的Android源代码树没有对出货设备中使用的无数芯片组的硬件支持。例如，AOSP很可能不支持你的高通芯片组。你的Exynos one肯定不是。联发科还是海思？算了吧！</p>

<section class="emaki-custom-block emaki-custom-pullquote"><div class="emaki-custom pullquote" id="custom_block_10"><p>BSP包含运行Android所需的驱动程序和硬件抽象层(HALs)</p> </div></section>
<p>现在需要的是一个<strong>板支持包(BSP) </strong>。这是一个由芯片组制造商交付给OEM的绝密专有组件包。BSP包含必要的源代码，让原始设备制造商为他们的设备构建Android和必要的驱动程序。</p>

<p>这里值得注意的是，像高通这样的原始设备制造商不一定完全信任他们的原始设备制造商合作伙伴BSP是在“需要知道”的基础上提供的。OEM厂商通常不会获得设备某些超级机密部分的源代码(比如运行在基带上的软件)。关闭这一部分当然也有潜在的问题，正如近期<a href="http://seclists.org/fulldisclosure/2015/Mar/160">大量</a>和<a href="https://github.com/programa-stic/security-advisories/blob/master/ObjSys/CVE-2016-5080/README.md">反复出现</a> ASN.1 <a href="https://www.rapid7.com/db/search?utf8=%E2%9C%93&amp;q=ASN.1&amp;t=a">解析漏洞</a>所示。</p>

<p>BSP包含在您的设备上运行Android所需的驱动程序和硬件抽象层(HALs)。AOSP包含一组Hal，作为操作系统期望你的驱动实现的定义。为了使用一个可笑的过度简化的(为了演示的目的而编造的)例子，让我们想象一下你手机上的手电筒。</p>

 
<h2 id="an-example-hal---your-flashlight">一个例子HAL -你的手电筒</h2>
<p>让我们想象你的设备背面有一个手电筒(如果你有一个Nexus 7 2013，你需要比其他人多做一点想象——抱歉！).这是由司机控制的。对于我们这个非常简单的例子，假设v1 HAL说你应该有一个名为“setLED”的函数，它只接受一个参数，即光的状态。这是一个布尔值-真或假。在C语言中，这看起来像这样:</p>

<p><code/></p>

<p>void setLED(bool ledState) {</p>

<p>//下面是根据ledState打开或关闭LED的实际代码</p>

<p>}</p>

<p/>

<p>该函数在BSP源代码中定义。然后，原始设备制造商在构建只读存储器时编译BSP，这就成为一种专有技术”。所以“设备的供应商分区或区域上的库”。这使得原始设备制造商可以对其设备的某些工作原理保密。现在，让我们假设他们不想让每个人看到他们是如何开关LED的。</p>

<p>现在想象一下，谷歌在未来版本的Android中发布了他们的HALs的更新版本。他们现在决定让你更新LED的亮度，而不仅仅是打开或关闭它。也许这是为了自适应闪存，或者也许只是为了强制HAL更新，让芯片组制造商继续营业？我们会让你，读者，在那个问题上得出你自己的看法。一些HAL更新确实有明显的好处(如新相机HAL曝光raw拍摄等)，而其他一些则在目的上不太明确。</p>

<p>有了这个新的(虚构的)HAL来表示亮度，让我们假设Google说您需要再次公开一个名为setLED的函数，但是这一次要为亮度传递一个整数。现在，0表示关闭，255表示开启。</p>

<p>如果你是原始设备制造商，你可以用你的超级密码打开那个LED，并把它放入这个新功能中。你甚至可以根据数字使用脉宽调制来调节LED的亮度。您现在将函数更改为如下所示:</p>

<p><code/></p>

<p>void set led(uint 8 _ t led brightness){</p>

<p>//一些超机密和超机密的专有方式来设置LED亮度</p>

<p>}</p>

<p/>

<p>那又怎样？好吧，现在这个新版本的Android与现有的“blobs”不兼容。您的OEM需要使用这些新的blobs，因为Android操作系统希望看到新的函数定义，而不会在寻找设置LED的方法时“找到”旧的函数定义。</p>

<h1>定制rom是怎么做的？</h1>
<p>此时，让我们稍作休息，看看自定义rom(从源代码构建)在这里是如何管理的。这就是你们当中精明的人现在会对着屏幕喊的话——毕竟，我们是XDA，是世界上寿命最长的手机HTC HD2的故乡...(声明一下，那边的疯狂天才们这几天在HD2上运行<a href="http://forum.xda-developers.com/hd2-android/nand-dev/17-2016-kernel-3-0-101-t3380832">Android 6.0</a>！对于2009年最初搭载Windows Mobile 6.5的手机来说，这已经不错了)</p>

<p/><p><a href="http://static1.xdaimages.com/wordpress/wp-content/uploads/2016/08/mspinside.png"> <img class=" wp-image-153337 alignright" src="../Images/3f9fe3def6fbcdb07bedde182cd54ee7.png" alt="mspinside" data-original-src="http://static1.xdaimages.com/wordpress/wp-content/uploads/2016/08/mspinside.png"/> </a>这里有各种各样的方法——有时开发者在ROM中乱搞，告诉操作系统使用旧的函数定义。这有点乱，需要做很多修改来维护。另一种方法是“填补”OEM二进制文件。</p>

<p/><p>“填补”方法是自己编写并构建一个小的新库，其中包含预期的函数定义——对于我们的例子，我们支持亮度的整数。然后，在shim中，这被翻译成满足旧HAL的要求。因此，对于我们的例子，我们可能会说，任何高于128的亮度要求都会打开LED，任何低于128的亮度要求都会关闭LED。或者你可以说任何非零值都会开启它。这取决于开发商。他们编译shim，并让Android使用它而不是原生的。然后，填充程序调用OEM blob。</p>

<p>一个快速的“adb push”和重启应该可以让shim运行，让你控制你的虚拟LED，即使你只有旧的HAL。</p>

<p>问题是，这显然是一个不完美的过程。你现在会得到一个怪癖——这个设备将有一个相当糟糕的闪光灯，要么完全打开，要么完全关闭。这并不理想——操作系统认为它在发出非常柔和的光，但实际的LED被告知它在参加人造太阳比赛，并试图蒙蔽你。但是，嘿，生活并不完美，你现在有一个旧手机上的工作LED！</p>

<p>(是的，这就是为什么XDA用户和开发人员在管理他们疯狂的移植技能时会有怪癖和错误的原因之一。我的意思是见鬼，<a href="http://forum.xda-developers.com/galaxy-s2"> Galaxy S II </a>搭载了看似可用的<a href="http://forum.xda-developers.com/galaxy-s2/development-derivatives/rom-t3356498"> Android 6.0 ROM now </a>。去年发布的很多手机还是没有6.0！)</p>

<h1>回到原始设备制造商</h1>
<p>让我们跳回原始设备制造商的角度。可悲的是，大多数原始设备制造商已经比我们现在领先至少一部手机。他们的重点是他们即将出售的下一部手机——你不能真的责怪他们，因为他们只在他们出售的设备上赚钱。他们没有从一两年前销售的设备中赚到任何钱，所以他们必须不断发布新设备才能生存。这是HTC和黑莓陷入困境的一个原因——不管有多少高管死抓着他们的旧黑莓曲线不放，因为他们不会在那里获得新的设备销售。</p>

<p>如果原始设备制造商没有BSP，他们不会走XDA的道路，拼凑一个版本。为什么？嗯，<strong>他们需要为他们的客户支持这个固件</strong>。如果他们发布了一个半工作的固件，用户会讨厌他们，咆哮和咆哮，并让他们的支持热线响了好几天。</p>

<p>原始设备制造商还必须与运营商竞争，至少在非欧洲市场是如此。运营商不希望客户在软件更新方面遇到问题。事实上，运营商通常不愿意发布软件更新。</p>

<p>为了理解这一点，想象一下你的姨婆爱丽丝。她就是那个在一天中不方便的时候打电话给你，请求你帮忙解决“那个电脑问题”的人。然后你描述如何点击“开始菜单”，并且必须识别出它是“左下角的大旗子”，并且遇到了困惑。大约45分钟后(非常沮丧), Alice阿姨把她的开始菜单拖到了屏幕右边，只需要把它拖回来。是的，用鼠标左键！</p>

<p>现在想象你有一千个爱丽丝阿姨。他们都在给你的客户支持打电话，无法在他们的手机上找到糖果粉碎，担心黑客从他们的手机上删除了它。哦，图标现在看起来有点不同了——也许黑客还在他们的手机里？</p>

<p>是的，这是一个轻松的幽默，但是在你体验到人们打电话给运营商寻求支持的原因之前，你不会相信他们遇到的问题。改变手机工作方式或位置的软件更新将导致巨大的支持开销。至少，它需要对支持人员进行再培训(遗憾的是，因为他们中的大多数人并不是你狂热的XDA读者)。</p>

<h1>OEM获得BSP</h1>
<p>一旦原始设备制造商得到BSP，他们将把他们的ROM移植过来，并把他们所有的改变应用到ROM上。他们会堆上他们的臃肿的器皿，并添加一个可怕的卡通式皮肤，在青少年的动漫中会看起来更自在。然后他们会测试它。</p>

<blockquote>
<p><strong>很多。</strong></p>
 </blockquote>
<p>你的手机必须符合各种各样的要求。移动网络被设计成信任用户设备(我们称之为电话)正确运行。这意味着该设备需要大量的测试才能获得批准。软件更新有改变行为的风险，所以需要再次测试。这就是为什么您通常会从外部测试服务中看到有关即将到来的索尼软件更新的信息，这些信息确认固件符合测试要求。</p>

<p>现在...更新一两次(或者在某些情况下，没有更新)后会发生什么？<strong>SoC制造商不会给OEM更新的BSP </strong>。毕竟，SoC制造商不会从中获得太多好处。自从你的手机售出后，原始设备制造商就再也没有从你的手机上赚到钱了。在这一点上，你的手机没有得到任何更多的主要版本更新。</p>

<p>削减OEM想要交付的bsp数量是一个节省资金的好方法——如果你只需要当前版本，并且不打算交付任何主要版本的增加，这将节省初始SoC购买和许可的资金，但代价是XDA的一些愤怒的书呆子，不知道为什么他们没有获得更新。</p>

<h1>那么这对于我手机上的更新意味着什么呢？</h1>
<p>更新是复杂的。这个链条中涉及到许多不同的人。所有这些都不能为原始设备制造商目前在安卓系统上缓慢而可悲的更新状态开脱。尽管如此，这里还是有一些真正的挑战。</p>

<p>许多原始设备制造商因承诺过多而受到指责，而<a href="http://www.androidpolice.com/2016/08/25/htcs-broken-15-day-update-promise-for-the-one-a9-is-a-small-symptom-of-a-larger-malady/">不可避免的交付不足，我们现在把它与</a>联系起来。可悲的现实是，对于大多数原始设备制造商来说，软件更新只是一件他们可以不需要的烦心事。</p>

<p>移动领域大多停留在功能手机的思维模式上。也就是说，设备永远得不到任何更新。测试一次，出货，永不回头。随着现代智能手机的安全问题，以及运行一个完整的通用操作系统的复杂性，以及数百个外部库，这不再是一个选项。或者至少它<em>不应该</em>是。谷歌已经采取了一些措施来解决这个问题，至少为现有版本的Android发布了安全公告和补丁(记住，直到最近，获得安全更新的唯一途径是通过一个新的主要Android操作系统版本！)</p>

<p>然而，遗憾的是，这还不够。即使谷歌不断发布更新，你的设备的安全性仍然取决于SoC制造商——由于SoC制造商非常害怕有人发现他们如何打开几个led或通过扬声器发出声音，他们在他们的设备上发布了大量的二进制blobs。这些blobs包含一些非常不安全的代码(如果你认为这是夸大其词，就看看过去的Google安全公告吧！)，需要更新。这意味着需要更新的bsp。</p>

<h1>但是为什么我的笔记本电脑不是这样的？</h1>
<p>台式电脑(以及延伸开来的笔记本电脑)在架构上与移动设备完全不同。你的手机或平板电脑实际上是一块严重专有的硅片，由一些好心人匆忙设计，但根本没有足够的时间做出好东西。市场变化如此之快，以至于他们几乎跟不上市场营销要求推出新产品的步伐。</p>

<p>这意味着走捷径——你不会发现你的手机受主流Linux内核支持，你会发现每部手机都有不同的启动方式。然而，在你的笔记本电脑或台式机上，供应商决定采用一些标准的引导方式——以前是带BIOS的MBR(主引导记录),现在是UEFI。这种标准化使得在每个设备上运行相同的软件成为可能。</p>

<p>虽然最近在这方面取得了一些进展，特别是索尼的外联计划和他们的<a href="https://github.com/sonyxperiadev/kernel">统一内核</a>，但在大多数手机上运行主线内核是不现实的，因为每款设备都引入了大量新的特定于供应商的黑客。</p>

<p>耳机插孔接线错误？直接黑进驱动程序里！生产设计的时候没时间修。</p>

<p>制造团队在生产批次1中倒置安装了摄像头模块？扔一个黑客进去检查内部版本代码，如果是版本1就把视频翻过来！</p>

<p>像这样的黑客解决了眼前的问题，但是仅仅触及了正在发生的奇怪的和特定于产品的变化的表面。见鬼，由于商业决策，同一款手机的不同版本有时甚至会有完全不同的芯片。这些导致了司机的黑客行为和当时才有意义的怪异决定，让手机正常工作，以便下周发货。</p>

<p>虽然有工作正在进行中，以主线支持64位ARM芯片使用UEFI启动，但到目前为止还没有一个更标准化的方式来启动ARM设备。这很可悲，因为这意味着手机在工作寿命结束之前将继续被扔掉，因为维持软件的技术债务和负担实在太昂贵了。</p>

<p>但另一方面，如果原始设备制造商只从销售设备中赚钱，他们难道不需要确保人们继续购买新手机吗？如果没有30年的发展势头和使用开放PC平台和标准的遗留软件，PC市场会转向这种模式吗？</p>

<h1>好了，回到正题！我的MSM8974呢？我会得到7.0分吗？</h1>
<p>这是一个没有高通内部消息的棘手问题，遗憾的是我们目前没有。但是，我们可以从7.0 Android驱动API和CTS要求中得出一些信息。CTS要求规定了谷歌对运行给定固件的设备的期望。用来执行这些要求的“大锤”是谷歌使用其专有Google Play服务捆绑包的许可- <strong>如果你不遵守，你就不能在设备上发布谷歌应用</strong>。虽然对于一些人来说，这种<a href="http://www.xda-developers.com/tag/say-sayonara/">可能会被视为一种优势</a>，但这显然不是用户想要和期望的设备。</p>

<p>Android 7.0对HAL或驱动程序(如上所述)没有太多的改动，所以任何不兼容都不太可能来自那里。然而，更有可能引起争议的是，为了通过CTS，Vulkan graphics API或GLES 3.1、引入了一个<strong>新要求。</strong></p>

<p>目前，许多片上系统(SOC)在其图形处理器上没有Vulkan支持，包括MSM8974。这也是最有可能出现与Android 7.0兼容性问题的地方。尽管如此，没有高通的内部消息，以及他们的未来计划，我们很难给出一个明确的声明而不加以限定。然而，目前我们认为这很可能是高通停止支持(在他们看来)老化的MSM8974芯片组，并且不在该平台上提供7.0的BSP(板支持包)的“简单”情况。如果是这样的话，这将意味着OEM厂商几乎肯定不会在设备上发布7.0-他们必须以某种方式找到Vulkan或GLEs 3.1对他们的GPU的支持，GPU源代码是移动堆栈中保护得非常严格的部分之一(没有真正的原因，我们会添加-见AMD，开源他们自己的Linux桌面AMDGPU驱动程序)。然而，可悲的是，Vulkan和加速(GLES)图形一般比简单的LED更复杂一些，所以这不是我们将要看到的引入兼容性的垫片。</p>

<p>由于7.0发布时间不长，其他芯片组(除了AOSP本土的少数芯片组)很可能会落后于6.0，这是由于硬件和驱动程序问题(即没有更新的BSP)或缺乏SoC供应商对Vulkan或GLES 3.1 API的支持。目前，Snapdragon 800和801都不支持其中之一。</p>

<p>最好的办法是关注这个空间-XDA的开发者已经在非官方移植到7.0上取得了良好的进展，许多设备没有得到谷歌官方的7.0支持。然而，这些没有Vulkan或GLES 3.1支持——如果足够多的用户开始运行没有Vulkan或GLES 3.1支持的定制rom，也许Android上的游戏开发者将开始经历碎片化的挫折？</p>

<p>苹果倾向于在最新的iOS版本上支持他们的iPhone系列大约5年iPhone 4s于2011年10月推出，并一直更新到iOS 9。然而，它不会收到即将到来的iOS 10更新，假设iOS 10在10月份左右推出，这将使手机的有效寿命达到5年。值得注意的是，苹果并不总是支持图形API——iPhone 4s和iPhone 5没有苹果的金属图形API，这与Android在Vulkan中看到的情况有些类似。唯一的区别是，苹果继续支持没有新图形API的旧设备。</p>

<p><em> <strong>你怎么看？你会在手机上闪存一个自定义ROM来延长它的使用寿命吗？你在下面的评论中说。</strong>T3】</em></p>

 </div>


</div>    
</body>
</html>