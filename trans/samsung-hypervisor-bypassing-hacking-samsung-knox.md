# 谷歌的 Project Zero 发现了如何绕过三星的 Knox 虚拟机监控程序(在 1 月份的补丁中修复)

> 原文：<https://www.xda-developers.com/samsung-hypervisor-bypassing-hacking-samsung-knox/>

谷歌的 Project Zero 团队已经证实了一些漏洞，这些漏洞使得运行理应安全的三星 Knox 安全套件的三星手机受到攻击。该博客指出，所有漏洞都已传递给三星，三星实际上已在 1 月份的软件更新中发布了补丁。

* * *

### 背景

作为三星推出的三星 Knox 安全软件套件的一部分，有一个软件位于 Android 应用程序和内核之间，称为**管理程序**。这可以用作进一步保护 Android 设备的附加层。Samsung Knox Hypervisor 被称为“**实时内核保护**”或简称 RKP，我将在本文的其余部分引用它。

在 Android 软件栈中，内核位于 RKP 之下，运行在设备上的应用程序位于顶部。RKP 背后的想法是为设备提供额外的安全层，因为应用程序向内核发出的所有请求(内存和其他资源)都必须首先通过 Knox，Knox 试图检测应用程序是否正在做它不应该做的事情。RKP 还通过一个额外的层来隐藏应用程序可能用来危害设备的敏感信息，从而通过隐藏来提供安全性。

博文深入探讨了 Android 内存、RKP 和操作系统的一般工作方式，因此我对其进行了浓缩和简化，以快速概述所发现的内容。不过，如果你有时间，我鼓励你阅读全文，因为它很有启发性。

* * *

### 漏洞#1:

**KASLR** 或内核地址空间布局随机化是在启动时随机改变内核代码在内存中的位置的过程。每次设备启动时，内核都被加载到不同的地址空间(内存区域)。这个想法是让找到内核代码的位置来攻击它变得更加困难，因为每次启动后，内核代码都会在内存中随机“移位”。这听起来像是防止潜在攻击者的一个伟大步骤，但最近的[研究](https://www.blackhat.com/docs/us-16/materials/us-16-Fogh-Using-Undocumented-CPU-Behaviour-To-See-Into-Kernel-Mode-And-Break-KASLR-In-The-Process.pdf)表明，你实际上可以在不需要软件错误或漏洞的情况下击败这一点，因为 KASLR 实际上很难以一种健壮的方式实现来对抗本地攻击者。

在 RKP 软件的情况下，绕过 KASLR 的能力实际上比上面提到的研究更简单。所有 android 设备的内存都是由指针引用的，为了保护设备免受攻击，每当 android 设备打印或输出(无论是筛选还是记录日志或调试)时，指针引用都是匿名的，这使得在读取输出时无法找到指针实际指向的位置。

把内存指针想象成指向一个位置的路标，把匿名想象成模糊这个位置。就像电视一样，匿名是在拍摄后完成的，Android 也在输出时应用这种匿名，并且只有在匿名配置正确的情况下，作者声明*他遇到的每个设备都正确配置了指针匿名*。这听起来似乎很难破解，但你需要做的只是找到一个指针(想想街道标志)，当指针被写入日志或其他位置(如屏幕或文件)时，它没有被内核开发人员匿名化(模糊化)(注意，这不是普通的 Android 应用程序开发人员)。

所以如果你能找到一个没有被匿名化的指针，那么你就可以计算内核的随机地址偏移，作为两者之间的差值。有趣的是，作者在内核中找不到可利用的指针，但在 RPK 中找到了，开发者忘记在调试(日志)输出中匿名化一个指针，这是由于打字错误。为了匿名化 Android 中的指针，你必须使用一种特殊的代码，结果是 RPK 开发人员错误地使用了**小写字母“K”**，而不是**大写字母“K”**。因此，计算出内核代码的随机偏移量并攻击它是相对简单的。

* * *

### 漏洞#2:

下一个漏洞有点复杂:Samsung Knox 通过对设备内存应用一套规则来阻止恶意代码，从而保护您的设备。规则如下:

1.  除了内核代码之外，所有页面(内存中的代码)都被标记为“特权永不执行”(意味着这里的代码永远不能运行)
2.  内核数据页(程序在内存中使用的数据)永远不会被标记为可执行的(所以这里的代码永远不会运行)
3.  内核代码页(内存中的代码)从不被标记为可写的(因此没有恶意代码可以改变它)
4.  所有内核页面在阶段 2 转换表(位于应用程序和内核之间以进一步防止应用程序知道实际内存位置的表)中被标记为只读
5.  对于应用程序，所有内存转换条目都标记为只读。

我们将把重点放在规则 3 上，因为这是作者发现上述规则的实现有问题的地方。RPK 实际上将内核的内存标记为只读，但是由于 KASL 的疏忽，发现了一个漏洞，导致**将代码写入所谓的“只读”部分**。为了在启动时混淆内核的位置，内存被分配给内核，但是这个内存量比内核的文本段大得多。通过分配更大的内存量，很难找到可能在任何地方的实际内核代码，正如我们在上面看到的，它是在设备每次启动时随机移动的。

 <picture>![kaslr_rwx (1).png](img/4aedaa5574c8bacf01c1e60b597a50ba.png)</picture> 

_text and _etext mark the protected range

作者能够确认内核使用的内存确实被标记为“只读”，然而用于隐藏内核的大量内存的其余部分被**而不是**标记为“只读”。这是因为 RKP 仅在应用 KASLR 幻灯片后保护包含内核文本的区域。

* * *

### 漏洞#3

在第三个漏洞中，作者能够访问另一个也应该限制为只读的内存区域。RKP 保护内存，并使用**虚拟机管理程序配置寄存器** (HCR)来控制关键的内核操作。HCR 的目的是允许有效和真实的内核操作访问寄存器并阻止恶意攻击。它通过检查对管理虚拟化特性的寄存器的调用来实现这一点。HCR 被配置为阻止正常情况下处理的特定操作，允许 RKP 选择是允许还是不允许请求。

在这个漏洞中，HCR 控件**没有覆盖两个寄存器**，这两个寄存器后来被证明是非常重要的。作者深入研究了 ARM 参考手册，发现第一个寄存器允许他基本上关闭应用程序的 RKP。EL1 的*系统控制寄存器(SCTLR_EL1)提供对系统的顶级控制，包括存储器系统*在理想情况下，应用程序将使用通过 RKP 映射的内存，以便 RKP 可以控制应用程序可以访问的内容。然而，关闭该寄存器允许通过有效地将设备恢复到安装 RKP 之前的运行方式来禁用**RKP**，这意味着设备被映射到物理内存，而没有 RKP 提供的额外安全性。这反过来意味着作者可以读写最初被 RKP 软件正确阻止的内存。

第二个被遗漏的注册表有一个更微妙的影响，但最终对安全性同样具有破坏性。EL1 (TCR_EL1)寄存器的**转换控制寄存器直接与应用程序使用的内存量(称为页面)相关。RKP 被硬编码为 4kb 的页面大小，因为 AARCH64 Linux 内核(如 Android)使用 4KB 的转换大小。相关寄存器(TCR_EL1)将 ARM 芯片组设置为要返回的内存大小。原来**这个寄存器不受 HCR** 的保护，因此攻击者可以在作者将其更改为 64kb 页面大小时对其进行更改。**

这意味着当 RKP 完成请求时，实际可访问的内存量现在是 64kb，而不是 4kb。原因是 ARM 芯片组仍然控制页面大小，它被漏洞设置为 64kb。由于 RKP 保护内存不被写入，作为漏洞#2 中列出的规则的一部分，内存实际上仍然受到保护。但是这里有一个问题——因为 RKP 被硬编码为 4kb，所以当寄存器被更新时，它不会改变为 64kb 的页面大小，所以**只有第一个 4kb 的内存受到保护**,允许攻击者对剩余的 60kb 内存做**他想做的任何事情**。

* * *

### 漏洞#4

作者展示的最后一个漏洞是引用 RKP 软件所在的内存，因此攻击者可以攻击 RKP 软件本身。阻止这种攻击的一个技巧是将你的程序从虚拟内存地址空间中取消映射，这样就没有应用程序能够攻击它，因为它们不能引用它。

请记住，内存就是指针和表，它们将物理内存映射到虚拟内存。按照这种类型攻击的常规防御，RKP 解除自身的映射，这样它就不会被攻击。然而，在内核没有提供这种能力的地方，RKP 允许一块内存被映射并标记为读/写。唯一的检查是它不是底层内核本身，因为 RKP 不检查被请求映射的地址是否是 RKP 本身驻留在内存中的区域。基本上，RKP **允许自己被重新映射**回应用程序可以访问的地址空间，并且作为一个副作用，**内存被自动标记为读/写**，因此攻击者现在可以随心所欲地使用内存。

* * *

## 结论

上面列出的四个漏洞利用的最大问题之一是，作者提到了由于基本 Android 内核中缺乏功能，执行这些会有多困难。具有讽刺意味的是，安全的 RKP 虚拟机管理程序提供了执行攻击所需的所有工具。这表明，有时善意的软件导致的问题比它解决的问题更多，我们很幸运，我们有像 Gal Beniamini 这样的人愿意亲自动手，测试文档是否与软件实际做的相匹配。

虽然这些漏洞看起来很可怕，让 Knox 听起来非常脆弱，但我想向大家保证，这些问题已经在三星的 1 月更新中得到解决。此外，这些漏洞需要对 ARM 处理器和编程有非常深刻的理解，因此使用这些漏洞的门槛非常高。

* * *

[**资料来源:零项目**](https://googleprojectzero.blogspot.com/2017/02/lifting-hyper-visor-bypassing-samsungs.html)