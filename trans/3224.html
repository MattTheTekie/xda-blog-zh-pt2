<html>
<head>
<title>DexPatcher: Patch Android APKs Using Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>DexPatcher:使用Java修补Android APKs</h1>
<blockquote>原文：<a href="https://www.xda-developers.com/dexpatcher-patch-android-apks-using-java/#0001-01-01">https://www.xda-developers.com/dexpatcher-patch-android-apks-using-java/#0001-01-01</a></blockquote><div><div class="content-block-regular">
<p>你可能已经看到或安装了修改过的应用程序，无论是为你的解决方案打了补丁的拨号器，还是添加了功能的自定义WhatsApp版本。然而，开发者是如何做到这一点的呢？很多时候，应用程序的源代码甚至都不可用，那么它是如何工作的呢？我们将首先看到这一点，然后看看一个旨在使这个过程变得更容易的新工具，最后将它与流行的Xposed框架进行比较，看看它们有什么不同。</p>

 
<h1>修改APKs:它是如何工作的？</h1>
<p>你可能听说过apk通常是如何被修改的——开发人员将自己插入矩阵，开始在Smali中看到一切，并获得使用源代码的力量修改东西的能力。一旦完成，一个电话就足以让他们离开，此时他们准备好分享闪亮的新apk。</p>

<p>更严重的是……我们从头说起吧。如果你不熟悉修改Android应用程序，你可能想知道smali是什么。开发者通常使用Java编程语言来编写Android应用程序。然后，一个程序(编译器)将该代码“翻译”成适合您的设备的另一种格式，结果是。应用程序包(或APK)中包含的dex文件。</p>

<p>此时，您将无法再访问原始源代码(除非您是开发人员或者应用程序是开源的)。然而，你拥有的是APK，因为它安装在你的设备上。从中，您可以获得dex文件(通常是classes.dex ),然后尝试将其转换回您可以理解的格式。这就是smali的用武之地，作为一个可读性更强但忠实的译本。你可以更进一步，把它翻译回Java，尽管这个过程不够忠实——你会得到一个可以理解的结果，但是你可能不能再反过来翻译它，因为一些细节会在这个过程中丢失。换句话说，你可能做的任何修改都是徒劳的，因为你无法再把它变回APK来安装到你的设备上…至少不需要付出很多努力。</p>

<p>smali/baksmali实际上是dex格式的汇编器/反汇编器——这就是它在冰岛语中的字面意思。然而，当我们说“smali”时，我们通常指的是Smali理解的格式(把它想象成定义每个小细节的指令，即使它不是我们人类所需要的——因此它比Java更冗长)。还要注意，上面的解释有点简化，但应该是一个接近的类比，同时仍然易于理解。</p>

<p>那么，开发者需要做什么来修改一个应用程序(不访问源代码)？这个过程大致如下:</p>

<ol> <li>获取APK(从网络或设备上)。</li> <li>使用类似<tt>apktool</tt>的东西将APK反编译成Smali。(<tt>apktool</tt>利用了smali/baksmali，但是使得反编译和重建apk变得容易得多，并且还负责像XML文件这样的解码资源。)</li> <li>从APK中提取classes.dex，然后使用<tt>dex2jar</tt>和最后一个Java反编译器来获得(不完整，经常出错，但基本上可以理解)Java代码。(这是可选的，但会有所帮助，因为Smali更难理解。)</li> <li>确定要修改的内容。</li> <li>实际上通过直接编辑Smali代码来修改它。</li> <li>或者，用Java编写修改，编译它，再反编译成Smali，然后复制生成的Smali代码。</li> <li>一切结束后，再次使用<tt>apktool</tt>来重建APK。</li> <li>签署APK(验证作者的身份；所有包都要签名)最后安装。</li> </ol>

<p>编写小代码非常困难，而且容易出错。在Smali中可以进行较小的更改，但是用它添加新功能更具挑战性。此外，您不会有任何编译时错误，所以即使是打字错误也可能只在运行时被检测到。扩展和共享Smali补丁也可能很麻烦，因为差异往往是特定于特定的APK版本的。尽管有一些工具可以使上面解释的部分过程变得更容易(想到了<a href="http://virtuous-ten-studio.com/">良性十工作室</a>)，但它仍然会令人厌倦。</p>

<h1>介绍DexPatcher</h1>
<p>XDA资深会员兰雄的DexPatcher旨在解决这些问题，方法是简化流程，让开发者完全避免与Smali打交道。相反，开发人员可以单独用Java编写补丁，让DexPatcher处理所有其他事情。</p>

<p>这有一个主要的优点，即补丁文件易于阅读和管理。一般来说，修补apk也变得更加方便。我们稍后将看到如何使用DexPatcher的完整示例，但这里先快速概述一下它提供的功能:</p>

<ul> <li><a href="https://github.com/Lanchon/DexPatcher/">开源</a>。</li> <li>跨平台:应该可以在Linux，Mac，Windows上运行。</li> <li>补丁文件:您所做的修改包含在您可以独立共享的Java补丁文件中。</li> <li>Java:不是Smali。</li> </ul>

<p>您还获得了构建时错误检查的优势，因此错误会在开发周期的早期出现。Java compiled提供了通常的编译时检查(可以访问原始的APK符号)，DexPatcher在打补丁时加强了源代码和补丁的兼容性，提供了有用的信息，并在您似乎在做合法但可疑的事情时发出警告。</p>

<p>除此之外，DexPatcher还附带了一组<a href="https://github.com/Lanchon/DexPatcher-scripts">助手脚本</a>(仅在Linux上可用，尽管它们也可以移植到其他平台上)。这些负责设置工作区，提取目标APK的类和资源，将类反编译成Java(后者使用了<a href="http://www.benf.org/other/cfr/"> CFR Java反编译器</a>)，最后在完成后构建并签署修补的APK。</p>

<p>让我们看一个例子(在Linux上):</p>

 
<h2 id="install-the-dexpatcher-scripts">安装DexPatcher脚本</h2>
<p/><pre><span>$</span> <span># Make a directory where we can test stuff out and enter it.

<p/></span><span>$</span> mkdir xda-test

<p><span/>$<span>CD</span>xda-test</p>

<p><span> $ </span> git克隆https://github.com/Lanchon/DexPatcher-scripts.git·德克斯帕彻<span> #克隆德克斯帕彻助手脚本repo。</span></p>

<p><span/><span>CD</span>dex patcher</p>

<p><span> $ </span> chmod +x dxp-* <span> #没有必要，但为了清楚起见:我们需要确保我们稍后调用的文件是可执行的。</span></p>

<p/></pre>
<p class="ad-odd"> </p>


<h2 id="configure-the-dexpatcher-scripts">配置DexPatcher脚本</h2>
<p>在您最喜欢的文本编辑器中打开<tt>dxp.config</tt>,确保更改必要的变量以适应您的系统。你只需要修改下面一行来指向你的Android SDK的安装位置:</p>

<p/><pre><span>dxp_android_sdk_dir</span><span>=(</span>~/android/sdk<span>)</span>

<p/></pre>

<p>(DexPatcher将自动选择可用的最高平台版本。此外，您还可以修改其他配置选项，让它使用您自己版本的一些工具，而不是捆绑的缺省值。)</p>

<p>为了便于访问，我们可以将<tt>dexpatcher</tt>目录添加到我们的<tt>PATH</tt>中，或者甚至将不同的<tt><span>dxp-*</span></tt>脚本符号链接到已经在您的<tt>PATH</tt>中的位置，例如<tt>~/bin</tt>:</p>

<p/><pre><span>export PATH=$PWD:$PATH</span>

<p/></pre>
<p class="ad-even"> </p>


<h2 id="modify-an-application">修改应用程序</h2>
<p>对于这个例子，我们将使用一个简单的开源应用程序。当然，在这种特殊情况下，直接修补源代码是可能的，但这一点也不好玩！</p>

<p>我们将采用basil2style的“Get ID”应用程序，该应用程序向您显示有关您设备的一些细节。我们的目标是修改“设备ID”的“复制”按钮，让它共享这个ID:</p>

<p><a href="http://www.xda-developers.com/wp-content/uploads/2015/03/DexPatcher_BeforePatch.png"/></p>



<p/>

<ul> <li>首先，让我们下载我们要修改的APK:<a href="https://f-droid.org/repository/browse/?fdid=makeinfo.com.getid">Get ID</a>。</li> <li>反编译应用程序。</li> <li>创建签名密钥，我们稍后将使用该密钥对APK进行签名。</li> </ul>

<p>我们也可以通过shell，使用助手脚本来完成这一切:</p>

<p/><pre><span>$</span> <span>cd </span>dexpatcher <span># Go to our working directory.

<p/></span><span>$</span> curl -O https://f-droid.org/repo/makeinfo.com.getid_1.apk <span># Download the APK.

<p/></span><span>$</span> dxp-setup-for-apk makeinfo.com.getid_1.apk <span># Unpack and decompile the APK.

<p/></span><span>$</span> <span>cd </span>makeinfo.com.getid_1 <span># Go to the newly created directory where everything is unpacked/decompiled to.

<p/></span><span>$</span> dxp-create-keystore <span># Create the APK signing key. Press 6 times (or fill out the info), then "yes".</span>

<p/></pre>

<p>您会注意到这里有几个不同的目录:</p>

<ul> <li><strong>解码</strong>:你会在这里找到资源和Smali，由<tt>apktool</tt>解码。</li> <li><strong> src </strong>:空目录。这是我们放置补丁文件的地方。</li> <li><strong> src-cfr </strong>:这是<tt>cfr</tt>反编译应用程序(以及错误)的地方。这是一个很好的地方，可以查看以决定要更改什么(您可能还需要上面的decode目录中的资源及其id，但不是针对这个特定的示例)。</li> <li><strong> src-cfr-nodecode </strong>:同上，但只包含空存根(没有代码，只有骨架)。您可以使用这些文件作为您的补丁的基础，我们稍后会看到。</li> </ul>

<p>正如我们之前提到的，我们希望更改设备ID的“复制”按钮来共享ID文本。如果我们看看源代码，我们会注意到设备ID复制按钮(<tt>device_copy</tt> ) <tt>onClick</tt>事件是由<tt><span>src-cfr/makeinfo/com/getid/MainActivity.java</span></tt>中的匿名类处理的。虽然我们可以在这里修改它，但通常最好找到一种替代方法，因为匿名类有数字名称(<tt>MainClassName$SomeNumber</tt>，例如<tt>MainActivity$3</tt>)，这可能会在版本之间发生不可预测的变化。</p>

<p>相反，我们将通过修改<tt>MainActivity</tt>类为事件注册我们自己的类。首先，让我们将“骨架”版本从<tt><span>src-cfr-nocode/makeinfo/com/getid/MainActivity.java</span></tt>复制到<tt>src/makeinfo/com/getid/MainActivity.java</tt>(记住<tt>src</tt>是我们补丁的所在)。(如果你愿意，也可以复制完整代码的版本，这纯粹是个人喜好问题。)</p>

<p>我们现在可以对其进行如下编辑:</p>

<ul> <li>为DexPatcher注释添加必要的导入:</li> </ul>

<p/><pre><span>import</span> <span>lanchon.dexpatcher.annotation.*</span><span>;</span>

<p/></pre>

<ul> <li>添加一个标签来表明我们正在编辑这个类。我们还将patch类成员的默认动作设置为<tt>IGNORE</tt>，这意味着这些成员在Java编译期间将被我们的代码引用，但将被DexPatcher忽略。</li> </ul>

<p/><pre><span>@DexEdit</span><span>(</span><span>defaultAction</span> <span>=</span> <span>DexAction</span><span>.</span><span>IGNORE</span><span>)</span>

<p><span>公共</span> <span>班级</span> <span>主要活动</span></p>

<p><span> //对ActionBarActivity的引用将由符号</span>来满足</p>

<p>//在我们构建补丁时从应用程序中提取。</p>

<p><span>扩展</span><span>ActionBarActivity</span><span>{</span></p>

<p/></pre>

<ul> <li>此外，向构造函数和<tt>onCreate</tt>方法添加空体，以及我们计划使用的所有其他方法(记住，当我们的补丁实际应用时，它们将被忽略——我们只是添加它们，所以如果需要，我们可以在这里引用它们)。您也可以只添加关键字<tt>native</tt>来代替。</li> <li>如果你好奇的话，我们现在已经可以构建补丁了:<pre><span>$</span> dxp-make <span># Output: `patched.apk`.</span></pre>很简单，对吧？不过，让我们继续——我们还没有完成。</li> <li>现在让我们编辑<tt>onCreate</tt>来设置自己的<tt>OnClickListener</tt>，这样我们就可以共享设备ID，而不是将其复制到剪贴板:<pre><span>// Rename the target method so that we can still call it (the original)// if needed.</span><span>@DexEdit</span><span>(</span><span>target</span> <span>=</span> <span>"onCreate"</span><span>)</span><span>protected</span> <span>void</span> <span>source_onCreate</span><span>(</span><span>Bundle</span> <span>var1</span><span>)</span> <span>{}</span><span>// Add our new custom method.</span><span>@Override</span><span>@DexAdd</span><span>protected</span> <span>void</span> <span>onCreate</span><span>(</span><span>Bundle</span> <span>var1</span><span>){</span> <span>// Call the original method:</span> <span>source_onCreate</span><span>(</span><span>var1</span><span>);</span> <span>// Replace the text and handler:</span> <span>device_copy</span><span>.</span><span>setText</span><span>(</span><span>"Share"</span><span>);</span> <span>device_copy</span><span>.</span><span>setOnClickListener</span><span>(</span><span>new</span> <span>DeviceCopyOnClick</span><span>());</span><span>}</span><span>// Note that we don't use an anonymous class to avoid nameclashing with// MainActivity$1, which already exists.// We also could've defined a nested MainActivity.Patch class and used// an anonymous class in MainActivity.Patch.onCreate(), and then called// MainActivity.Patch.onCreate() from MainActivity.onCreate().</span><span>@DexAdd</span><span>class</span> <span>DeviceCopyOnClick</span> <span>implements</span> <span>View</span><span>.</span><span>OnClickListener</span> <span>{</span> <span>@Override</span> <span>public</span> <span>void</span> <span>onClick</span><span>(</span><span>View</span> <span>object</span><span>)</span> <span>{</span> <span>if</span> <span>(</span><span>MainActivity</span><span>.</span><span>this</span><span>.</span><span>val</span><span>)</span> <span>{</span> <span>Intent</span> <span>intent</span> <span>=</span> <span>new</span> <span>Intent</span><span>(</span><span>Intent</span><span>.</span><span>ACTION_SEND</span><span>);</span> <span>intent</span><span>.</span><span>setType</span><span>(</span><span>"text/plain"</span><span>);</span> <span>intent</span><span>.</span><span>putExtra</span><span>(</span><span>Intent</span><span>.</span><span>EXTRA_SUBJECT</span><span>,</span> <span>"Device ID"</span><span>);</span> <span>intent</span><span>.</span><span>putExtra</span><span>(</span><span>Intent</span><span>.</span><span>EXTRA_TEXT</span><span>,</span> <span>device</span><span>.</span><span>getText</span><span>().</span><span>toString</span><span>());</span> <span>startActivity</span><span>(</span><span>Intent</span><span>.</span><span>createChooser</span><span>(</span><span>intent</span><span>,</span> <span>"Share Device ID"</span><span>));</span> <span>}</span> <span>else</span> <span>{</span> <span>Toast</span><span>.</span><span>makeText</span><span>(</span><span>MainActivity</span><span>.</span><span>this</span><span>.</span><span>getApplicationContext</span><span>(),</span> <span>"Nothing to Share"</span><span>,</span> <span>0</span><span>).</span><span>show</span><span>();</span> <span>}</span> <span>}</span><span>}</span></pre></li> <li>看起来我们现在完成了！完整的补丁应该看起来像<a href="https://gist.github.com/GermainZ/5eecb0a32599aae59649">这个</a>。我们现在可以构建打了补丁的APK并安装它:<pre><span>$</span> dxp-make<span>$</span> adb install patched.apk</pre></li> <li>让我们来看看结果:</li> </ul>

<p><a href="http://www.xda-developers.com/wp-content/uploads/2015/03/DexPatcher_AfterPatch.png"/></p>



<p/>

<p>(感谢Lanchon帮助编写示例代码！)</p>

<h1>DexPatcher与Xposed有何不同</h1>
<p>Xposed非常受欢迎，这是有原因的——它使得开发人员和用户构建、共享和安装mods更加简单。DexPatcher和Xposed之间有一些差异，这可能会使一些人更喜欢其中的一个:</p>

<ol> <li>Xposed通过在运行时挂钩方法，允许开发人员在任何方法之前、之后或替代任何方法做一些事情，来实现它的魔力。另一方面，DexPatcher在运行时之前修改一切，并生成一个独立的、经过修改的APK代码——在方法之前、之后或代替方法运行仍然是可能的，并且您实际上有一些额外的自由。</li> <li>生产一个独立的APK意味着它不依赖于任何外部框架。这也意味着修改用户应用程序不需要root。</li> <li>因为你用DexPatcher创建了一个新的APK，它的签名将会不同。这意味着用户无法收到原作者的官方更新，如果签名被检查，可能会导致谷歌应用程序等应用程序出现一些问题。</li> <li>模块和DexPatcher补丁的源代码都可以很容易地分发和修改。如果你对每一个都有点熟悉的话，它们也有许多相似之处。</li> </ol>

<h1>现在就去拿</h1>
<p>我们已经谈得够多了。现在轮到你试一试了，所以直接去<a href="http://forum.xda-developers.com/android/software/tool-dexpatcher-modify-android-dex-apk-t3060854"> DexPatcher论坛主题</a>开始吧！</p>

 </div>


</div>    
</body>
</html>