<html>
<head>
<title>[Update: Second Vulnerability Patched] Two Critical OnePlus 3/3T Bootloader Security Flaws Discovered, One Patched and Other being Addressed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>[更新:第二个漏洞已修补]发现两个严重的OnePlus 3/3T引导加载程序安全漏洞，一个已修补，另一个正在解决</h1>
<blockquote>原文：<a href="https://www.xda-developers.com/two-critical-oneplus-33t-bootloader-security-flaws-discovered-one-patched-and-other-being-addressed/#0001-01-01">https://www.xda-developers.com/two-critical-oneplus-33t-bootloader-security-flaws-discovered-one-patched-and-other-being-addressed/#0001-01-01</a></blockquote><div><div class="content-block-regular">
<section class="emaki-custom-block emaki-custom-note"><div class="emaki-custom note" id="custom_block_0"><p>自本文发表以来，Oxygen OS 4 . 0 . 3版本已经修补了本文讨论的第二个安全漏洞，即dm-verity漏洞。</p> </div></section>
<p/><p>在进入Android生根、定制rom、内核和其他修改的奇妙世界之前，您首先必须解锁设备上的引导加载程序。</p>

  
<p>在一些设备上(尤其是运营商品牌的设备)，这造成了一个问题，因为用户必须在解锁引导加载程序之前处理重大的技术障碍。华为手机等其他设备要求你向原始设备制造商申请一个独特的引导加载程序解锁代码——这是一个小小的障碍，但并不十分困难。更好的是谷歌Nexus/Pixel系列或一加手机，它们只需要你在开发者设置中勾选一个选项，然后发送几个<em>快速启动</em>命令。</p>

<p>但是不管解锁你的引导程序有多难，有一件事是永远不变的:解锁后擦除设备的要求。这样做是出于明显的安全原因，因为一旦bootloader解锁，您的整个数据分区就可以很容易地被提取出来。如果恶意实体(拥有技术知识)能够访问您的数据，他们可以快速启动自定义恢复并提取您设备的完整备份。这就是为什么解锁您的引导加载程序被认为是一个安全风险，也是为什么您的设备在解锁后会被擦除。假设一切正常，普通用户应该不会被攻击者解锁引导加载程序来绕过标准的Android锁定方法。然而，并非一切都按计划进行。</p>

<hr/>


<h2 id="oneplus-3-3t-bootloader-unlocking-vulnerability">OnePlus 3/3T引导加载程序解锁漏洞</h2>
<p>Roee Hay(<a href="https://twitter.com/roeehay">@ roe Hay</a>)刚刚披露了一组新的漏洞<a href="https://securityresear.ch/2017/02/08/oneplus3-bootloader-vulns/#exploiting-cve-2017-5626-for-kernel-code-execution">，其中第一个漏洞允许OnePlus 3/3T的引导加载程序解锁<strong>，无需用户确认，也无需触发工厂重置。</strong>这个标记为</a><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5626"> CVE-2017-5625 </a>的漏洞被认为是一个严重漏洞，它会影响所有运行OxygenOS 3.2-4.0.1的OnePlus 3/3T设备。已经升级到<a href="https://forums.oneplus.net/threads/oxygenos-4-0-2-n-ota-for-oneplus-3.489599/"> incremental OxygenOS 4.0.2 </a>更新<strong>的用户不会受到这个漏洞的影响</strong>，因为Hay先生在1月23日私下向一加<strong>透露了这个缺陷，所以他们可以立即修补这个问题。</strong></p>

<p>该漏洞通过发送专有的隐藏快速启动命令:<code>fastboot oem 4F500301</code>来工作。通过发送该命令，绕过用户的引导加载程序锁定状态(即使在开发者设置中没有启用“允许OEM解锁”时)。设备不会提示用户，也不会像应该的那样擦除设备——事实上，设备仍然会报告引导加载程序被锁定！另一个快速引导命令<code>fastboot oem 4F500302</code>将重置一些引导程序设置，并可用于锁定已经解锁的设备。</p>

<p>Hay先生发现，第一个快速启动命令设置了他所谓的“<strong> magicFlag </strong>”，它覆盖了在执行闪存或擦除命令时确定引导加载程序锁定状态的检查。</p>

<pre> <code class="hljs java"><br/><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub_918427F0</span><span class="hljs-params">()</span></span><br/>{<br/>  magicFlag_dword_91989C10 = 1;<br/>  if ( dword_9198D804 != dword_9198D804 )<br/>    <span class="hljs-keyword">assert</span>(<span class="hljs-number">1</span>, dword_9198D804, dword_9198D804);<br/>  <span class="hljs-keyword">return</span> sendOK((<span class="hljs-keyword">int</span>)<span class="hljs-string">""</span>, dword_9198D804);<br/>}<br/></code> </pre>
<section class="emaki-custom-block emaki-custom-expandable"><div class="emaki-custom expandable" id="custom_block_10"><h3 id="fastboot-flash-handler">快速启动闪存处理程序</h3><pre> <code class="hljs java"><br/><br/><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-function">__fastcall <span class="hljs-title">sub_91847EEC</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *partitionName, <span class="hljs-keyword">int</span> *a2, <span class="hljs-keyword">int</span> a3)</span></span><br/>{<br/>  <span class="hljs-keyword">char</span> *pname; <br/>...<br/>  pname = partitionName;<br/>  v4 = a2;<br/>  v5 = a3;<br/>  <span class="hljs-keyword">if</span> ( returnTRUE1(partitionName, (<span class="hljs-keyword">int</span>)a2) )<br/>  {<br/>    result = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)sub_918428F0(pname, v6);<br/>    if ( (result || magicFlag_dword_91989C10)<br/>      &amp;&amp; ((result = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)sub_91842880(pname, v10)) != <span class="hljs-number">0</span> || magicFlag_dword_91989C10) )<br/>    {<br/>      result = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)sub_918428F0(pname, v10);<br/>      if ( !result || magicFlag_dword_91989C10 )<br/>        <span class="hljs-keyword">goto</span> LABEL_7;<br/>      v8 = dword_9198D804;<br/>      if ( dword_9198D804 != dword_9198D804 )<br/>        <span class="hljs-keyword">goto</span> LABEL_28;<br/>      v11 = <span class="hljs-string">"Critical partition flashing is not allowed"</span>;<br/>    }<br/>    <span class="hljs-keyword">else</span><br/>    {<br/>      v8 = dword_9198D804;<br/>      if ( dword_9198D804 != dword_9198D804 )<br/>        <span class="hljs-keyword">goto</span> LABEL_28;<br/>      v11 = <span class="hljs-string">"Partition flashing is not allowed"</span>;<br/>    }<br/>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)FAIL2((<span class="hljs-keyword">int</span>)v11, v10);<br/>  }<br/>LABEL_7:<br/>  ...<br/>    if ( *v4 != 0xED26FF3A )<br/>    {<br/>      if ( *v4 == 0xCE1AD63C )<br/>        cmd_flash_meta_img(pname, (unsigned <span class="hljs-keyword">int</span>)v4, v5);<br/>      <span class="hljs-keyword">else</span><br/>        cmd_flash_mmc_img(pname, (<span class="hljs-keyword">int</span>)v4, v5);<br/>      <span class="hljs-keyword">goto</span> LABEL_10;<br/>    }<br/>    v7 = v4;<br/>  }<br/>  cmd_flash_mmc_sparse_img(pname, (<span class="hljs-keyword">int</span>)v7, v5);<br/>  ...<br/> }<br/></code> </pre> </div></section>
<section class="emaki-custom-block emaki-custom-expandable"><div class="emaki-custom expandable" id="custom_block_11"><h3 id="fastboot-erase-handler">Fastboot Erase指令</h3><pre> <code class="hljs java"><br/><br/><span class="hljs-function"><span class="hljs-keyword">int</span> __fastcall <span class="hljs-title">sub_91847118</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *partitionName, <span class="hljs-keyword">int</span> a2, <span class="hljs-keyword">int</span> a3)</span></span><br/>{<br/> ...<br/>  v3 = partitionName;<br/>  v4 = returnTRUE1(partitionName, a2);<br/>  if ( !v4 )<br/>  {<br/>LABEL_7:<br/>    ...<br/>    if ( v4 )<br/>    {<br/>      if ( dword_9198D804 == dword_9198D804 )<br/>        <span class="hljs-keyword">return</span> eraseParition(v3);<br/>    }<br/>    ...<br/>  }<br/>  v4 = sub_918428F0(v3, v5);<br/>  if ( !v4 &amp;&amp; !magicFlag_dword_91989C10 )<br/>  {<br/>    v6 = dword_9198D804;<br/>    if ( dword_9198D804 == dword_9198D804 )<br/>    {<br/>      v7 = <span class="hljs-string">"Partition erase is not allowed"</span>;<br/>      <span class="hljs-keyword">return</span> FAIL2((<span class="hljs-keyword">int</span>)v7, v5);<br/>    }<br/>    <span class="hljs-keyword">goto</span> LABEL_23;<br/>  }<br/>  v4 = sub_91842880(v3, v5);<br/>  if ( !v4 &amp;&amp; !magicFlag_dword_91989C10 )<br/>  {<br/>    v6 = dword_9198D804;<br/>    if ( dword_9198D804 == dword_9198D804 )<br/>    {<br/>      v7 = <span class="hljs-string">"Partition flashing is not allowed"</span>;<br/>      <span class="hljs-keyword">return</span> FAIL2((<span class="hljs-keyword">int</span>)v7, v5);<br/>    }<br/>LABEL_23:<br/>    <span class="hljs-keyword">assert</span>(v4, v5, v6);<br/>  }<br/>  v4 = sub_918428F0(v3, v5);<br/>  if ( !v4 || magicFlag_dword_91989C10 )<br/>    <span class="hljs-keyword">goto</span> LABEL_7;<br/>  v6 = dword_9198D804;<br/>  ...<br/>  v7 = <span class="hljs-string">"Critical partition erase is not allowed"</span>;<br/>  <span class="hljs-keyword">return</span> FAIL2((<span class="hljs-keyword">int</span>)v7, v5);<br/>}<br/></code> </pre> </div></section>
<p>CVE-2017-5626可以用来<strong>执行内核代码</strong>。攻击者可以刷新他们想要的任何启动映像。但是，如果他们刷新一个修改过的引导镜像，验证过的引导就会启动，并警告用户已经检测到修改。有一种方法可以绕过这个问题，那就是刷新一个旧的、未修改的启动映像——一个包含旧的漏洞的映像，这些漏洞已经被打了补丁。即便如此，您得到的“警告”仅持续5秒钟，它会自动解除自身并引导至verifiedboot状态，攻击者的代码仍将在该状态下执行。</p>

<p>Hay先生提到有很多方法可以恶意利用这个缺陷。例如，他修改了一个引导映像，将SELinux模式设置为<em>许可</em>，并在引导时自动包含ADB访问。然后，在利用这个漏洞刷新他修改过的启动映像后，他能够在用户输入他们的凭证之前访问一个<strong>根shell。</strong></p>

<pre> <code class="hljs bash">OnePlus3:/ <br/>uid=0(root) gid=0(root) groups=0(root),1004(input),1007(<span class="hljs-built_in">log</span>),1011(adb),<br/>1015(sdcard_rw),1028(sdcard_r),3001(net_bt_admin),3002(net_bt),<br/>3003(inet),3006(net_bw_stats),3009(readproc) context=u:r:su:s0<br/><br/>OnePlus3:/ <br/>Permissive<br/></code> </pre>
<p>不用说，这是相当严重的。您认为由于您的典型安全措施而安全的被盗或被屏蔽的设备可以使用此漏洞完全击败。</p>

<hr/>
<p class="ad-odd"> </p>


<h2 id="oneplus-3-3t-selinux-vulnerability">OnePlus 3/3T SELinux漏洞</h2>
<p>第二个漏洞，标记为<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5624"> CVE-2017-5624 </a>，影响<strong>oxygen OS</strong>的所有版本，并允许<strong>禁用dm-verity。</strong>Hay先生于1月16日<strong/>向一加安全团队披露了该漏洞，但需要注意的是，XDA资深会员<a href="https://forum.xda-developers.com/member.php?u=3878912"> th3g1z </a> <a href="https://forum.xda-developers.com/showpost.php?p=70698410&amp;postcount=112">于1月23日<strong/>独立发现该漏洞</a>。我们与一加进行了对话，他们已经确认他们已经承认并将在未来的更新中修复第二个漏洞。</p>

<p>这种攻击执行起来也相当简单。只需发出一个快速启动命令就可以禁用(或启用)dm-verity: <code>fastboot oem disable dm-verity</code>。要启用它，只需发出<code>fastboot oem enable dm-verity</code>。该命令的处理程序取自引导装载程序的转储，如下所示。</p>

<pre> <code class="hljs java"><br/><br/><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub_9183B8EC</span><span class="hljs-params">()</span></span><br/>{<br/>  <span class="hljs-keyword">int</span> v0; <br/>  <span class="hljs-keyword">int</span> v1; <br/><br/>  dmVerity_dword_91960740 = 0;<br/>  v0 = sub_91845E10(<span class="hljs-string">"ANDROID-BOOT!"</span>);<br/>  if ( dword_9198D804 != dword_9198D804 )<br/>    <span class="hljs-keyword">assert</span>(v0, v1, dword_9198D804);<br/>  <span class="hljs-keyword">return</span> sendOK((<span class="hljs-keyword">int</span>)<span class="hljs-string">""</span>, v1);<br/>}<br/></code> </pre>
<p>发出这个命令将设置一个标志，Hay先生称之为dmVerity，引导装载程序使用它来发送一个内核命令行参数，该参数可以启用或禁用dm-verity。</p>





<p>这可以与第一个漏洞结合使用，在未经用户同意的情况下在OnePlus 3/3T上执行高度特权代码，并访问用户的数据。例如，Hay先生能够将一个应用程序安装到/system/priv-app，这使得该应用程序被添加到priv-app域。这使得恶意应用程序能够访问设备上的高特权功能。在下面的视频中，Hay先生展示了这两种漏洞被同时利用的情况。如您所见，当他启动设备时，他构建的应用程序显示为已经预装。</p>

 
<p class="w-rich w-youtube" id="x5FG4Sb5kog">  </p>


<hr/>
<p class="ad-even"> </p>


<h2 id="conclusion-amp-note-from-oneplus">一加的结论和说明</h2>
<p>这两个安全漏洞的潜在滥用是可怕的。我们赞扬海先生私下里如此迅速地向一加披露了这些漏洞。尽管如此，我们还是忍不住对这些设备上可以使用这样的快速启动命令感到担忧。当我们编写如何<a href="https://www.xda-developers.com/how-to-discover-hidden-fastboot-commands/">发现隐藏的快速启动命令</a>的指南时，我们的意图是告诉用户，他们可以使用一些有趣的命令来增强他们的体验。<strong>我们从来没有想到如此高特权的命令会存在于引导程序代码中</strong>。至于<strong>“为什么”</strong>这些快速启动命令包含在固件中，我们得到的是<strong>“无可奉告。”</strong></p>

<p>目前，如果你没有在每个Oxygen OS版本发布后立即更新OnePlus 3/3T，我们建议你立即更新。更新到Oxygen OS 4.0.2将保护你免受第一个漏洞的攻击，但我们必须等到一加推出修补第二个漏洞的更新后，才能说你完全安全免受这些攻击。我们将不得不在未来继续关注这种利用。</p>

<hr/>

<p><a href="https://securityresear.ch/2017/02/08/oneplus3-bootloader-vulns/#exploiting-cve-2017-5626-for-kernel-code-execution"> <strong>来源:roe有</strong> </a></p>

 </div>


</div>    
</body>
</html>