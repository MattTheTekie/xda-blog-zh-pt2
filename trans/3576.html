<html>
<head>
<title>Diving into SDCardFS: How Google's FUSE Replacement Will Reduce I/O Overhead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>深入SDCardFS:Google的保险丝更换将如何降低I/O开销</h1>
<blockquote>原文：<a href="https://www.xda-developers.com/diving-into-sdcardfs-how-googles-fuse-replacement-will-reduce-io-overhead/#0001-01-01">https://www.xda-developers.com/diving-into-sdcardfs-how-googles-fuse-replacement-will-reduce-io-overhead/#0001-01-01</a></blockquote><div><div class="content-block-regular">
<p/><p>几个月前，谷歌在Linux内核的AOSP官方分支中添加了一个名为“<strong> SDCardFS </strong>的东西。当时，这一举动只被<a href="https://twitter.com/arter97/status/712615865800220672?lang=en">的一些内核开发者</a>注意到，但在其他方面却被大多数用户忽略了。考虑到大多数用户，包括我自己，并不真正知道Android操作系统及其内核下发生了什么，这并不奇怪。</p>

  
<p>然而，最近一集的<em> <a href="https://androidbackstage.blogspot.com/"> Android开发者后台</a> </em>播客重新引起了人们对这个话题的兴趣。该播客由Chet Haase(谷歌高级软件工程师)主持，探讨了内核最近和即将发生的变化。在节目中有一位在Android团队工作的Linux内核开发人员——Rom le marchand。两人主要讨论了为适应A/B更新所做的改变，但在这一集的最后5分钟，勒马尔钱德先生谈到了他的团队正在进行的“下一件大事”——<strong>SDCardFS</strong>。</p>

<p>我必须承认，我是听了这个播客才知道SDCardFS的存在的。当然，我不是唯一对这个话题感兴趣的人，正如最近Reddit上的一个帖子所显示的。然而，我对播客中提供的基本解释并不满意，为了消除一些正在传播的错误信息，我自己做了一些研究，并与一些具有相关知识的专家进行了交谈。</p>

<p>非常感谢软件开发人员迈克尔·科瓦尔茨克为本文贡献他的知识，并花时间回答我的问题。</p>

<hr/>


<h2 id="external-is-really-internal">“外在”其实是内在的</h2>
<p>马上，我们必须澄清一些误解——否则文章的其余部分将会非常混乱。讨论SD卡和安卓手机的历史很有帮助。</p>

<p>在Android手机的早期，几乎所有设备都依赖于使用microSD卡进行存储。这是因为当时的手机内部存储容量很小。然而，用于存储应用程序的SD卡通常无法提供出色的用户体验，至少与内部闪存读取/写入数据的速度相比是如此。因此，越来越多地使用SD卡进行外部数据存储成为了谷歌的用户体验问题。</p>

<p>由于SD卡作为外部存储设备的早期扩散，Android的存储命名约定基于这样一个事实，即每个设备都有一个实际的物理microSD卡插槽。但是，即使在不包含SD卡插槽的设备上,/sdcard标签仍然用于指向实际的内部存储芯片。更令人困惑的是，利用物理SD卡和高容量存储芯片进行存储的设备通常会根据SD卡来命名它们的分区。例如，在这些设备中,/sdcard挂载点指的是实际的内部存储芯片，而/storage/sdcard1则指的是物理外部卡。</p>



<p>因此，尽管microSD卡实际上被认为是外部存储器，但命名惯例导致“SD card”在物理卡的任何实际使用之后仍然存在。这种与存储的混淆也给应用程序开发人员带来了一些麻烦，因为应用程序数据及其媒体在两个分区之间是分离的。</p>

<p>早期内部存储芯片的低存储空间导致用户沮丧地发现他们不能再安装应用程序(由于/data分区已满)。与此同时，他们更大容量的microSD卡被降级为只能存储媒体(如照片、音乐和电影)。以前浏览我们论坛的用户可能还记得这些名字:Link2SD和Apps2SD。这些是(根)解决方案，使用户能够将其应用程序和数据全部安装在物理SD卡上。但是这些都不是完美的解决方案，所以谷歌不得不介入。</p>

<p>众所周知，谷歌很早就拔掉了SD卡的插头。Nexus One仍然是唯一一款配有microSD卡插槽的Nexus设备(而且将永远如此，因为Nexus品牌实际上已经死亡)。有了Nexus S，现在只有一个统一的分区来存储所有应用程序数据和媒体，即/data分区。曾经被称为/sdcard挂载点现在只是指位于数据分区- /data/media/0中的虚拟文件系统(在下面讨论的<strong> FUSE </strong>协议下实现)。</p>

<p>为了保持兼容性和减少混乱，谷歌仍然使用这个现在虚拟的“sdcard”分区来保存媒体。但是现在这个“sdcard”虚拟分区实际上位于/data中，其中存储的任何内容都将计入内部存储芯片的存储空间。因此，原始设备制造商需要考虑将多少空间分配给应用程序(/data)还是分配给介质(/data/media)。</p>
<div class="body-img landscape"><div class="responsive-img image-expandable img-article-item" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/01/2-1.png" data-modal-id="single-image-modal" data-modal-container-id="single-image-modal-container" data-img-caption="&quot;Two Very Different \&quot;SD Cards\&quot;&quot;">
 
<figure> <picture>  <source media="(min-width: 1024px)" sizes="1500px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/01/2-1.png?q=50&amp;fit=crop&amp;w=1500&amp;dpr=1.5"/> <source media="(min-width: 768px)" sizes="943px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/01/2-1.png?q=50&amp;fit=crop&amp;w=943&amp;dpr=1.5"/> <source media="(min-width: 481px)" sizes="767px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/01/2-1.png?q=50&amp;fit=crop&amp;w=767&amp;dpr=1.5"/> <source media="(min-width: 0px)" sizes="480px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/01/2-1.png?q=50&amp;fit=crop&amp;w=480&amp;dpr=1.5"/> <img class="lazyload" alt="" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/01/2-1.png" src="../Images/32639251f9920512e68f7cd457c0cd99.png" data-original-src="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/01/2-1.png"/> </picture> <figcaption class="body-img-caption">Two Very Different "SD Cards"</figcaption> </figure> </div>


 </div>


<p>谷歌希望制造商效仿他们的做法，放弃SD卡。幸运的是，随着时间的推移，手机制造商能够以更高的容量采购这些组件，同时保持成本效益，因此对SD卡的需求开始减少。但是命名约定一直存在，以减少开发人员和OEM不得不进行调整的工作量。目前，当我们提到“外部存储”时，我们指的是<a href="https://developer.android.com/guide/topics/data/data-storage.html#filesExternal">以下两者之一</a>:实际的可移动microSD卡或位于/data/media中的虚拟“SD card”分区。实际上，后者<em>实际上是内部存储</em>，但谷歌的命名约定将其区分开来，因为用户可以访问这些数据(例如当插入计算机时)。</p>

<blockquote>
<p>目前，当我们提到“外部存储”时，我们指的是<a href="https://developer.android.com/guide/topics/data/data-storage.html#filesExternal">以下两者之一</a>:实际的可移动microSD卡或位于/data/media中的虚拟“SD card”分区。</p>
 </blockquote>
<hr/>
<p class="ad-odd"> </p>


<h2 id="the-history-of-android-s-virtual-filesystems">Android虚拟文件系统的历史</h2>
<p>既然“sdcard”被视为虚拟文件系统，这意味着它可以被格式化为Google想要的任何文件系统。从Nexus S和Android 2.3开始，谷歌选择将“sdcard”格式化为VFAT(虚拟脂肪)。这一举措在当时是有意义的，因为安装VFAT将允许几乎任何电脑访问你手机上存储的数据。然而，这个初始实现有两个主要问题。</p>

<p>第一个主要关系到最终用户(您)。为了将设备连接到电脑，您需要使用USB大容量存储模式来传输数据。然而，这需要Android设备在计算机可以访问数据之前卸载虚拟分区。如果用户想在接通电源的情况下使用他们的设备，许多东西会显示为不可用。</p>



<p>媒体传输协议 (MTP)的引入解决了第一个问题。接通电源后，您的电脑会将您的设备视为“媒体储存”设备。它会从你的手机上请求一份文件列表，MTP会返回一份电脑可以从手机上下载的文件列表。当请求删除某个文件时，MTP会发送一条命令，将所请求的文件从存储中删除。与实际安装“SD卡”的USB大容量存储模式不同，MTP允许用户在插电时继续使用他们的设备。此外，Android手机上的文件系统对于计算机识别设备上的文件不再重要。</p>

<p>其次，VFAT没有提供谷歌需要的那种强大的权限管理。早期，许多应用程序开发人员将“sdcard”视为应用程序数据的转储地，没有统一的文件存储位置。许多应用程序会简单地用它的应用程序名称创建一个文件夹，并在那里存储它的文件。</p>

<p>当时几乎每个应用程序都需要<a href="https://developer.android.com/reference/android/Manifest.permission.html#WRITE_EXTERNAL_STORAGE"> WRITE_EXTERNAL_STORAGE </a>许可才能将应用程序文件写入外部存储器。然而，更麻烦的是，几乎每个应用程序都需要<a href="https://developer.android.com/reference/android/Manifest.permission.html#READ_EXTERNAL_STORAGE"> READ_EXTERNAL_STORAGE </a>权限——只是为了读取它们自己的数据文件！这意味着应用程序可以轻松地访问存储在外部存储设备上任何地方的数据，而且这种权限通常由用户授予，因为这是许多应用程序运行所必需的。</p>

<p>谷歌显然认为这有问题。权限管理背后的整个想法是分离应用程序可以访问和不可以访问的内容。如果几乎每个应用程序都被授予读取潜在敏感用户数据的权限，那么这种权限就毫无意义。因此，谷歌决定他们需要一种新的方法。这就是导火索的由来。</p>

<hr/>
<p class="ad-even"> </p>


<h2 id="filesystem-in-userspace-fuse">用户空间中的文件系统(FUSE)</h2>
<p>从Android 4.4开始，谷歌决定不再将虚拟的“sdcard”分区挂载为VFAT。相反，Google开始使用FUSE在“sdcard”虚拟分区上模拟FAT32。随着sdcard程序调用<a href="http://androidxref.com/6.0.0_r5/xref/system/core/sdcard/sdcard.c"> FUSE来模拟FAT-on-sdcard风格的目录权限</a>，应用可以开始访问其存储在外部存储<em>上的数据，而无需任何权限</em>。事实上，从API Level 19开始，READ_EXTERNAL_STORAGE不再需要访问位于外部存储上的文件——前提是FUSE守护程序创建的数据文件夹与应用的包名匹配。当一个应用程序被安装时，FUSE将处理<a href="https://source.android.com/devices/storage/">合成外部存储器上文件的所有者、组和模式</a>。</p>

<p>FUSE不同于内核模块，因为它允许非特权用户编写虚拟文件系统。Google实现FUSE的原因很简单——它做了他们想做的事情，并且已经被Linux世界很好地理解和记录。引用一位<a href="https://groups.google.com/d/msg/android-platform/U-pUof6PGNo/ei3F-_2fCAAJ">谷歌开发者关于此事的话</a>:</p>

<blockquote>
<p/><h4>“因为FUSE是一个很好的稳定的API，所以在内核版本之间移动时基本上不需要任何维护工作。如果我们迁移到内核解决方案，我们将为每个稳定的内核版本维护一组补丁。”——杰夫·夏基，谷歌软件工程师</h4>
 </blockquote>
<p>然而，越来越明显的是，FUSE的开销在其他问题中对性能产生了影响。我就此事与开发人员迈克尔·科瓦尔茨克交谈过，他在一年前写了一篇精彩的博客文章，详细介绍了FUSE当前的问题。更多的技术细节可以在他的博客上阅读，但我会用更通俗的语言描述他的发现(在他的允许下)。</p>

<hr/>
<p class="ad-odd"> </p>


<h2 id="the-problem-with-fuse">保险丝的问题是</h2>
<p>在Android中，“sdcard”用户空间守护进程利用FUSE在启动时将/dev/fuse挂载到模拟的外部存储目录。之后，sdcard守护进程会轮询FUSE设备以获取来自内核的任何未决消息。如果你听了播客，你可能听过Lemarchand先生提到FUSE在I/O操作中引入开销——下面是实际情况。</p>

<blockquote>
<p>在现实世界中，这种性能影响会影响存储在外部存储器上的任何文件。</p>
 </blockquote>
<p><em> <strong>问题# 1——I/O开销</strong> </em></p>

<p>假设我们创建了一个简单的文本文件，名为“test.txt ”,并将其存储在/sdcard/test.txt中(让我提醒您，该文件实际上是/data/media/0/test.txt，假设当前用户是设备上的主用户)。如果我们想读取(命令cat)这个文件，我们会期望系统发出3个命令:打开，读取，然后关闭。事实上，正如科瓦尔茨克用strace 演示的那样，事情就是这样发生的:</p>



<p>但是由于该文件位于由sdcard守护进程管理的外部存储器上，因此需要执行许多额外的操作。根据科瓦尔茨克先生的说法，这三个独立命令中的每一个<em>基本上都需要8个额外的步骤:</em></p>

<ol> <li>用户空间应用程序发出系统调用，该调用将由内核中的FUSE驱动程序处理(我们在第一个strace输出中看到)</li> <li>内核中的FUSE驱动程序通知用户空间守护进程(sdcard)有新的请求</li> <li>用户空间守护进程读取/dev/fuse</li> <li>用户空间守护进程解析命令并识别文件操作(例如打开)</li> <li>用户空间守护进程向实际的文件系统发出系统调用(EXT4)</li> <li>内核处理物理数据访问，并将数据发送回用户空间</li> <li>用户空间修改(或不修改)数据，并通过/dev/fuse再次传递给内核</li> <li>内核完成最初的系统调用，并将数据移动到实际的用户空间应用程序(在我们的示例cat中)</li> </ol>

<p>对于要运行的单个I/O命令来说，这似乎是一笔很大的开销。你是对的。为了证明这一点，科瓦尔茨克先生尝试了两种不同的I/O测试:一种是复制一个大文件，另一种是复制许多小文件。他比较了FUSE(在装载为FAT32的虚拟分区上)和内核(在格式化为EXT4的数据分区上)处理这些操作的速度，他发现FUSE确实造成了很大的开销。</p>



<p>在第一个测试中，他在两种测试条件下复制了一个725MB的文件。他发现FUSE实现传输大文件的速度<strong>比</strong>慢17%。</p>



<p>在第二次测试中，他复制了10，000个文件——每个文件大小为5kb。在这种情况下，FUSE实现比<strong>慢40秒</strong>来复制基本上50MBs的数据。</p>

<p>在现实世界中，这种性能影响会影响存储在外部存储器上的任何文件。这意味着应用程序，如在/sdcard上存储大文件的地图，存储大量音乐文件的音乐应用程序，相机应用程序和照片等。任何涉及外部存储的I/O操作都会受到FUSE开销的影响。但是I/O开销并不是FUSE的唯一问题。</p>

<p><em> <strong>问题# 2——双缓存</strong> </em></p>

<p>数据缓存对于提高数据访问性能非常重要。通过在内存中存储重要的数据，Linux内核能够在需要时快速调用这些数据。但由于FUSE的实现方式，Android存储的缓存量是所需的两倍。</p>

<p>正如科瓦尔茨克先生所演示的那样，一个10MB的文件被保存在缓存中的时间预计正好是10MB，但是缓存的大小却增加了大约20mb。这在RAM较少的设备上是个问题，因为Linux内核存储使用页面缓存在内存中存储数据。科瓦尔茨克先生用这种方法测试了双重缓存的问题:</p>

<ol> <li>创建一个已知大小的文件(用于测试，10MBs)</li> <li>将其复制到/sdcard</li> <li>删除页面缓存</li> <li>拍摄页面缓存使用情况的快照</li> <li>阅读测试文件</li> <li>拍摄页面缓存使用的另一个快照</li> </ol>

<p>他发现在他的测试之前，241MBs被内核用于页面缓存。一旦他阅读了他的测试文件，他期望看到251MBs用于页面缓存。相反，他发现那个内核使用了<strong>263 MB</strong>用于页面缓存——大约是预期的两倍<strong>。出现这种情况的原因是，数据首先由最初发出I/O调用的用户应用程序(FUSE)缓存，然后由sdcard守护进程(EXT4 FS)缓存。</strong></p>

<p><em> <strong>问题# 3——fat 32</strong></em>执行不完整</p>

<p>使用模拟FAT32的FUSE还有另外两个问题，在Android社区中不太为人所知。</p>

<p>第一个问题涉及<strong>不正确的时间戳</strong>。如果你曾经传输过一个文件(比如一张照片)并注意到时间戳不正确，那是因为Android实现了FUSE。这个问题<a href="https://code.google.com/p/android/issues/detail?id=34691">已经存在<strong>年</strong>T5年了。更具体地说，这个问题涉及到<em> utime() </em>系统调用，它允许您更改文件的访问和修改时间。不幸的是，作为标准用户对sdcard守护进程的调用没有执行该系统调用的适当权限。对此有变通办法，但它们要求您</a><a href="https://forum.xda-developers.com/android/general/guide-timestamp-attributes-correct-t2960935">拥有根访问权限</a>。</p>

<blockquote>
<p>如果你曾经传输过一个文件(比如一张照片)并注意到时间戳不正确，那是因为Android实现了FUSE。</p>
 </blockquote>
<p>下一个问题对于使用类似于智能SD卡的企业来说更令人担忧。在FUSE之前，应用程序制造商可以监控<a href="https://code.google.com/p/android/issues/detail?id=67406"> O_DIRECT标志</a>，以便与卡中的嵌入式微控制器进行通信。使用FUSE，开发人员只能访问文件的缓存版本，而看不到微控制器发送的任何命令。这对于一些与增值microSD卡通信的企业/政府/银行应用程序来说是个问题。</p>

<hr/>
<p class="ad-even"> </p>


<h2 id="dumping-fuse-for-sdcardfs">SDCardFS的转储保险丝</h2>
<p>一些OEMS很早就认识到了这些问题，并开始寻找一种内核解决方案来替代FUSE。比如三星就开发了基于WrapFS的<strong> SDCardFS </strong>。这个内核解决方案就像FUSE一样模拟FAT32，但是放弃了I/O开销、双重缓存和我上面提到的其他问题。(是的，让我重申这一点，<strong>谷歌现在实施的这个解决方案是基于三星的工作</strong>)。</p>

<p>谷歌自己终于承认了FUSE的缺点，这也是他们开始转向三星开发的内核FAT32仿真层的原因。正如Android开发者后台播客中提到的，该公司一直致力于在即将发布的内核版本中使SDCardFS可用于所有设备。你目前可以看到他们在AOSP 的<a href="https://android.googlesource.com/kernel/common.git/+/android-4.1/fs/sdcardfs/">工作进展。</a></p>

<p>正如<a href="https://groups.google.com/d/msg/android-platform/U-pUof6PGNo/ei3F-_2fCAAJ"> Google开发人员在前面</a>解释的那样，实现内核解决方案的最大挑战是如何将包名映射到应用程序ID，这是包在不需要任何权限的情况下访问外部存储中自己的数据所必需的。但这一声明是在一年前做出的，我们已经到了团队将SDCardFS称为他们的“下一件大事”的地步他们已经证实了<a href="https://code.google.com/p/android/issues/detail?id=18624#c128">可怕的时间戳错误</a>已经修复，这要感谢远离FUSE，所以我们可以期待看到放弃FUSE带来的所有变化。</p>

<hr/>
<p class="ad-odd"> </p>


<h2 id="fact-checking-misconceptions">事实核查误解</h2>
<p>如果你已经读到这篇文章的这一步，那么到目前为止，你能跟上每一步都是值得称赞的！我想澄清我自己在写这篇文章时的几个问题:</p>

<ul> <li>SDCardFS】与实际SD卡无关。之所以这样命名，是因为它处理/sdcard的I/O访问。你可能还记得，/sdcard是一个过时的标签，指的是设备的“外部”存储(应用程序存储媒体的地方)。</li> <li>SDCardFS<strong>不是FAT32、EXT4或F2FS这样的传统文件系统</strong>。它是一个可堆叠的包装文件系统，将命令传递给较低的仿真文件系统(在本例中，它是/sdcard上的FAT32)。</li> <li>对于MTP来说，一切都不会改变。你将继续使用MTP在你的电脑上传输文件(直到谷歌找到一个更好的协议)。但至少时间戳错误会被修复！</li> <li>如前所述，当Google提到“外部存储”时，他们要么是在谈论(出于所有意图和目的)internal /sdcard虚拟FAT32分区，要么是在谈论实际的、物理的、可移动的microSD卡。术语令人困惑，但这正是我们印象深刻的。</li> </ul>

<hr/>
<p class="ad-even"> </p>


<h2 id="conclusion">结论</h2>
<p>通过摆脱FUSE并实现内核FAT32仿真层(SDCardFS)，Google将减少大量I/O开销，消除双重缓存，并解决一些与FUSE的FAT32仿真相关的模糊问题。</p>

<p>由于这些改变将会在内核中进行，所以它们可以在没有新版本Android的情况下推出。一些用户期待看到这些变化在Android 8中正式实现，但任何未来在Pixel设备上的OTA都有可能带来谷歌一直在努力的Linux内核版本4.1。</p>

<p>对于你们中的一些人来说，SDCardFS并不是一个新概念。事实上，三星设备已经使用它很多年了(毕竟是他们开发的)。自从SDCardFS去年在AOSP推出以来，一些定制ROM和内核开发人员已经选择在他们的工作中实现它。CyanogenMOD一度考虑过实现它，但当用户的照片遇到问题时，就放弃了。但希望随着谷歌在这个项目上占据主导地位，所有未来设备上的Android用户都可以利用放弃FUSE带来的改进。</p>

 </div>


</div>    
</body>
</html>