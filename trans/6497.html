<html>
<head>
<title>Scoped Storage in Android Q forces developers to use SAF, which sucks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Android Q中的作用域存储迫使开发者使用SAF，这很糟糕</h1>
<blockquote>原文：<a href="https://www.xda-developers.com/android-q-storage-access-framework-scoped-storage/#0001-01-01">https://www.xda-developers.com/android-q-storage-access-framework-scoped-storage/#0001-01-01</a></blockquote><div><div class="content-block-regular">
<p/><p>Android Q从根本上改变了手机的存储方式。在Pie之前的每个版本中，Android的存储都像台式电脑一样工作:你可以使用任何你想读或写任何文件的应用程序(如果你授予应用程序这样做的权限)。随着Q的推出，谷歌正在引入(并要求)“T0”范围的存储，这使得Android的工作更像iPhone，其中存储被隔离到每个应用程序。一个应用程序只能访问它自己的文件，如果卸载它，它的所有文件都会被删除。</p>

  
<p>令人欣慰的是，Android Q仍然保留了Android中央文件系统的一些原始行为。不幸的是，现在用户设置应用程序来访问它很麻烦，并且大大降低了性能和功能。开发者将不得不重新编写大量的应用程序来支持它。</p>

<p>需要一般文件系统访问的应用程序，例如office套件、图像编辑器或文件管理器，现在需要使用一个名为“<a href="https://developer.android.com/guide/topics/providers/document-provider">存储访问框架</a>”(SAF)的Android API来进行所有文件操作。SAF自Android 5.0 Lollipop以来就已经存在，但开发人员倾向于不使用它，除非需要，因为它有一个困难且缺乏文档记录的API，用户体验差，性能差，可靠性差(主要表现为设备供应商特定的实现问题)。由于向SAF过渡的困难，谷歌决定允许尚未表明支持Android Q的应用像以前一样工作，但明年Play Store要求所有应用支持Q时，这种情况将会改变。</p>

<p>SAF最明显的面向用户的变化是授予应用程序访问存储的体验。要让应用程序获得访问权限，它需要向操作系统发出请求，然后操作系统会显示一个目录选择器屏幕。在这个屏幕上，用户选择文件夹层次结构的根，应用程序将能够在其中读写文件。对于需要访问本地文件的每个应用程序，用户都必须完成这一过程；如果用户还需要授权它访问外部SD卡，则每个应用程序需要完成两次。</p>

<p>谷歌至少在第三次测试中改进了这一过程，因为之前的测试版甚至不允许应用程序建议用户选择位置，这<a href="https://issuetracker.google.com/issues/130522927">要求用户做相当多的工作</a>来实际找到他们设备的主存储。</p>

<p>在SAF下，文件I/O性能受到了一定的影响，但最突出的问题在于文件目录操作，它比Pie中可能的传统文件访问慢25到50倍。对于文件管理器来说，这意味着执行搜索和存储使用量计算将需要几个数量级的时间。这里有一个带有演示应用的错误报告。</p>
<div class="body-img portrait"><div class="responsive-img image-expandable img-article-item-portrait" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2019/05/SAF-Performance.png" data-modal-id="single-image-modal" data-modal-container-id="single-image-modal-container" data-img-caption="&quot;Sample test run of SAFTest showing the performance difference between the conventional file I\/O API with SAF.&quot;">
 
<figure> <picture>  <source media="(min-width: 1024px)" sizes="750px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2019/05/SAF-Performance.png?q=50&amp;fit=crop&amp;dpr=1.5"/> <source media="(min-width: 768px)" sizes="750px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2019/05/SAF-Performance.png?q=50&amp;fit=crop&amp;dpr=1.5"/> <source media="(min-width: 481px)" sizes="600px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2019/05/SAF-Performance.png?q=50&amp;fit=crop&amp;dpr=1.5"/> <source media="(min-width: 0px)" sizes="360px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2019/05/SAF-Performance.png?q=50&amp;fit=crop&amp;dpr=1.5"/> <img class="lazyload" alt="" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2019/05/SAF-Performance.png" src="../Images/8b72a9b3c942e1d517e4b7bd8aff548e.png" data-original-src="https://static1.xdaimages.com/wordpress/wp-content/uploads/2019/05/SAF-Performance.png"/> </picture> <figcaption class="body-img-caption">Sample test run of SAFTest showing the performance difference between the conventional file I/O API with SAF.</figcaption> </figure> </div>


 </div>


<p>一个更大的性能问题是，一些应用程序必须将文件复制到本地“范围存储”区域，然后才能使用它们。当这种文件的大小为几千兆字节时，例如在视频文件或压缩档案的情况下，这可能是有问题的。许多Android应用程序利用了开发人员社区中数量惊人的开源Java库，这些库通常需要直接访问文件系统才能工作。它们不是特定于Android的，需要重写才能与SAF一起工作。更糟糕的是，Android自己的许多内部库都无法与之兼容，比如包管理器或zip API。例如，如果不首先将整个APK复制到它自己的作用域存储区域，文件管理器甚至不能显示APK文件的图标(使用标准的Android API)。<a href="https://issuetracker.google.com/issues/130494105">错误报告。</a></p>

<p>对于喜欢技术的人来说，现在可以通过ADB使用appops命令禁用Android Q的“作用域存储”。根用户可以直接在他们的设备上执行命令，而无需台式计算机。这些命令在文档中被描述为开发人员功能，因此可以随时删除。</p>

<p><strong>为应用启用常规存储访问:</strong></p>

<pre> <code class="hljs sql">adb shell cmd appops <span class="hljs-keyword">set</span> your-<span class="hljs-keyword">package</span>-<span class="hljs-keyword">name</span> android:legacy_storage <span class="hljs-keyword">allow</span> &amp;&amp; \adb shell am <span class="hljs-keyword">force</span>-<span class="hljs-keyword">stop</span> your-<span class="hljs-keyword">package</span>-<span class="hljs-keyword">name</span></code> </pre>
<p><strong>禁用应用的常规存储访问:</strong></p>

<pre> <code class="hljs sql">adb shell cmd appops <span class="hljs-keyword">set</span> your-<span class="hljs-keyword">package</span>-<span class="hljs-keyword">name</span> android:legacy_storage <span class="hljs-keyword">default</span> &amp;&amp; \adb shell am <span class="hljs-keyword">force</span>-<span class="hljs-keyword">stop</span> your-<span class="hljs-keyword">package</span>-<span class="hljs-keyword">name</span></code> </pre>
<p>谷歌吹捧这一变化的安全和隐私好处，但从技术上来说，没有任何改善。从Android 1.0开始，应用程序就有了私人存储文件的能力，几乎所有的应用程序都利用了这一功能。当您通过SAF授予应用程序对存储根目录的访问权限时，它可以读取、写入任何文件，并将其发送给恶意的开发人员，就像您授予应用程序对Pie中存储的访问权限一样。</p>

<p>唯一的“安全改进”是因为现在对用户来说这是一个更加困难的过程。当然，除非某个应用程序只想窃取你最私人的信息，比如你拍摄的照片和视频，为此谷歌增加了一个替代访问解决方案，使用一个简单的弹出安全对话框“点击-是”。</p>

<p>谷歌希望通过这种改变获得什么好处，目前还不得而知。Android Q beta文档中的官方原因是“让用户对他们的文件有更多的控制权，并限制文件混乱。”目前形式的作用域存储是对用户被允许做什么的新限制，而不是他们控制的延伸。减少混乱的说法可能有些道理，但仅仅是因为这种变化减少了使用文件的能力。当你考虑到一些应用程序现在不得不复制文件来使用它们时，“混乱”就增加了。</p>

<p>如果谷歌真的关心让用户对文件和混乱有更多的控制权，他们应该设计一个直接解决这个问题的解决方案，而不是错误地将当前的Android Q设计称为这样的改进。最简单的答案是让用户使用现有的存储权限请求对话框来决定他们是否希望应用程序具有范围或一般文件系统访问权限。如果用户特别担心在这里做出糟糕的决定，当然可以让这个对话框更加突出，并要求额外的用户交互来批准应用程序的完全访问权限。</p>

<p>Android如何让用户更多地控制他们的文件的答案是，实际上给用户更多的控制，而不是剥夺和从根本上限制Android平台的能力。</p>

<hr/>

<p><em>编者按:这是XDA资深会员<a href="https://forum.xda-developers.com/member.php?u=2954544">特利贝克</a>撰写的客座文章，他因在<a href="https://play.google.com/store/apps/details?id=nextapp.fx"> FX文件浏览器</a>上的工作而闻名。这篇文章的内容反映了他自己对Android Q的范围存储限制的看法和分析，并由XDA开发者杂志的主编米沙·拉赫曼进行了最少的输入和编辑。我们联系了谷歌，询问他们对这些问题的一些担忧，但截至发稿时，还没有收到该公司的回复。</em></p>

 </div>


</div>    
</body>
</html>