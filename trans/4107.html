<html>
<head>
<title>Cameras in Custom ROMs: How Developers Make Hardware Work without Source Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>定制rom中的相机:开发者如何在没有源代码的情况下使硬件工作</h1>
<blockquote>原文：<a href="https://www.xda-developers.com/cameras-custom-roms-developers-make-hardware-work-without-source-code/#0001-01-01">https://www.xda-developers.com/cameras-custom-roms-developers-make-hardware-work-without-source-code/#0001-01-01</a></blockquote><div><div class="content-block-regular">
<p/><p>随着Android Oreo和许多设备的发布，如<a href="https://www.xda-developers.com/xiaomi-redmi-note-3-unofficial-android-oreo/">小米Redmi Note 3 </a>、<a href="https://forum.xda-developers.com/google-nexus-5/orig-development/aosp-oreo-8-0-0-nexus-5-t3664033">谷歌Nexus 5 </a>和<a href="https://www.xda-developers.com/list-android-oreo-unofficial-ports/">其他非官方接收它的设备</a>，人们可能有理由怀疑，当开发者移植基于Android开源项目(AOSP)的ROM时，为什么相同的功能(主要是摄像头)往往会被破坏。你可能见过XDA论坛的rom线程，上面有一长串损坏的功能。“什么有效”后面是一个工作特性列表，下面是标志性的“什么无效？你告诉我！”在我们的论坛上有两个流行的说法，在Reddit和Twitter等网站上几乎已经成为了一个迷因。</p>

  
<p>为什么每当开发人员试图将AOSP ROM移植到他们的设备上时，会有如此多的功能被破坏？基本的答案是，因为不同版本的Android功能不同，打包成BLOBs的旧设备驱动程序不能与新版本的Android兼容，甚至不能与普通的AOSP兼容。为了克服这一点，开发人员使用了所谓的“垫片”，但是这个过程非常复杂、耗时，有时很难调试。</p>

<p>在这篇文章中，我们将概述垫片如何工作，特别是关于让相机在基于AOSP的rom上正常工作。我们将以OnePlus 3T为例。请注意，实现这些功能的难度与具体设备高度相关。</p>

<p/><p><img class="alignnone wp-image-169606 size-full" src="../Images/9d333820fff7f90d053a5429c34074f9.png" alt="" data-original-src="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/03/oos2.jpg"/> <em> OnePlus 3T运行OxygenOS。</em> <em>虽然一加手机以定制开发友好著称，但开发者在幕后做了大量工作，打造稳定的AOSP端口。</em></p>

<hr/>


<h2 id="what-is-a-shim-or-a-blob">什么是垫片或斑点？</h2>
<p>为了开始理解开发人员在做什么，我们首先需要解释一些事情。虽然Android操作系统是开源的(它被称为Android开源项目是有原因的)，但数以千计的Android设备上安装的软件(没有内核)却不是。开发者无法获得<a href="https://www.xda-developers.com/galaxy-note-8-software-spen-apps/">三星体验</a>、<a href="https://www.xda-developers.com/huawei-reveals-details-of-emui-5-1-update/"> EMUI </a>、<a href="https://www.xda-developers.com/opinion-oxygenos-exemplary-oem-rom/"> OxygenOS </a>的源代码，或者任何其他第三方版本的Android。</p>

<p>现在，将股票AOSP移植到非谷歌设备上的开发者可能不关心这些Android皮肤的源代码，因为他们不会修改和构建这些rom。这是真的，如果不是因为一个很大很大的原因:让相机正常工作所必需的部分，主要是<a href="https://source.android.com/devices/camera/">相机HAL </a>(硬件抽象层)<i>也是闭源</i>。</p>

<p>不仅有相机HAL，还有ROM闭源的问题是，致力于将AOSP移植到他们设备上的开发人员将<strong>盲目工作</strong>。闭源OEM ROM能够很好地与相机HAL接口，因为OEM可以访问相机HAL源。摄像头HAL允许ROM与摄像头硬件“对话”——没有它，摄像头将不起作用。把摄像机HAL想象成汽车的方向盘和踏板。方向盘/踏板通过为驾驶员提供外部接口(ROM)来使用内部部件，从而允许控制车辆的内部部件。</p>
<div class="body-img portrait"><div class="responsive-img image-expandable img-article-item-portrait" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/camera-HAL-278x300.png" data-modal-id="single-image-modal" data-modal-container-id="single-image-modal-container" data-img-caption="&quot;Graphic showing the camera architecture. Source: &lt;a href=\&quot;https:\/\/source.android.com\/devices\/camera\/\&quot;&gt;Google&lt;\/a&gt;&quot;">
 
<figure> <picture>  <source media="(min-width: 1024px)" sizes="750px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/camera-HAL-278x300.png?q=50&amp;fit=crop&amp;dpr=1.5"/> <source media="(min-width: 768px)" sizes="750px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/camera-HAL-278x300.png?q=50&amp;fit=crop&amp;dpr=1.5"/> <source media="(min-width: 481px)" sizes="600px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/camera-HAL-278x300.png?q=50&amp;fit=crop&amp;dpr=1.5"/> <source media="(min-width: 0px)" sizes="360px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/camera-HAL-278x300.png?q=50&amp;fit=crop&amp;dpr=1.5"/> <img class="lazyload" alt="" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/camera-HAL-278x300.png" src="../Images/b96b3bb5278cbb73a3f6b7296e2c230c.png" data-original-src="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/camera-HAL-278x300.png"/> </picture> <figcaption class="body-img-caption">Graphic showing the camera architecture. Source: <a href="https://source.android.com/devices/camera/">Google</a></figcaption> </figure> </div>


 </div>


<p>随着相机硬件变得越来越复杂(例如，双相机的<a href="https://www.xda-developers.com/oneplus-5-xda-first-impressions-upgrade/">出现)，访问相机HAL源代码将使移植带有功能相机的AOSP ROM变得更加容易。</a></p>

<p>然而，由于各种原因，OEM不提供对相机HAL源的访问。首先，如果他们没有照相机HAL的所有所有权(例如当他们合并来自其他公司的知识产权时)，那么他们不能分发源代码。第二，发布相机HAL源代码可能会危及他们自己的知识产权。最后，公司没有法律义务提供这些源代码(不像内核源代码，根据GPL ，他们<a href="https://www.xda-developers.com/xda-developers-and-the-gpl/">有义务发布这些源代码)，因此他们没有动机发布这些代码。因此，如果没有相机HAL源代码，开发者如何让相机在AOSP rom上工作呢？答案是一个BLOB，shim，还有许许多多的调试。</a></p>

<p>设备<strong> BLOB </strong>(二进制大对象)包含预打包的二进制文件，它们是软件的编译形式。在这种情况下，相机HAL源代码由OEM编译，并作为二进制文件安装在设备上。当开发人员谈论BLOBs时，他们指的是在他们能够提取的活动设备上发布的那些二进制文件。现在,“相机斑点”的话题已经困扰了<a href="https://www.xda-developers.com/oneplus-invites-user-opinion-on-camera-blob-release-on-oneplus-3/">一加</a>好几个月了，但是事实的真相是开发者一直都可以访问相机斑点。虽然,<strong>相机HAL源代码是开发者的黄金门票</strong>,但由于它会给像一加这样的公司带来法律风险，所以<strong>永远不会发布</strong>。</p>

<p>因此，希望将AOSP带到设备上的开发人员只剩下摄像头HAL的斑点，他们无法访问这些斑点的源代码。开发人员很少能够将他们的AOSP ROM代码与相机HAL BLOB配对并期望它工作，因此为了弥合两者之间的差距，开发人员创建了所谓的“<strong>垫片</strong></p>

<p>“填补”就是“楔入(某物)或填满一个空间。”这实际上是开发人员在编写填充程序时所做的事情——他们添加代码以允许BLOB与他们正在处理的AOSP源代码进行交互。匀场被用来使所有不同种类的斑点与AOSP一起工作，但通常，它是相机斑点需要最多的匀场。正如我们之前提到的，填隙不仅是将较新版本的Android移植到设备上(比如所有那些非官方的Android Oreo ROMs)所需要的，而且是将相同Android版本的AOSP移植到该设备上所需要的。</p>

<p><em> <strong>推荐阅读:</strong> </em> <a href="https://www.xda-developers.com/in-depth-capitulation-of-why-msm8974-devices-are-excluded-from-nougat/">从商店到货架:深入剖析为什么MSM8974设备被排除在牛轧糖之外</a></p>

<p>例如，OnePlus 2以Android 6.0棉花糖的形式收到了其最后一次官方主要操作系统更新。然而，这款设备实际上拥有<a href="https://forum.xda-developers.com/oneplus-2/development">基于Android牛轧糖的完全定制的AOSP rom</a>，这要归功于开发者和他们的垫片的辛勤工作。我们将分解一些垫片的例子，但首先，我们需要谈谈垫片到底是如何工作的。</p>

<hr/>
<p class="ad-odd"> </p>


<h2 id="how-does-shimming-work">匀场是如何工作的？</h2>
<p>由于开发者没有权限访问相机HAL或OEM ROM源码(只有预编译的二进制)，所以他们无法知道相机HAL期望什么功能。因此，HAL寻找的函数名和开发人员正在使用的AOSP代码中的实际函数名经常不匹配。</p>

<p>为了解决这个问题，开发人员只需创建一个新函数，该函数使用与相机HAL BLOB期望的函数相同的名称，但这个新函数只是执行开发人员希望它执行的内容。这个在BLOB和AOSP之间充当中间人的新函数就是shim。斑点找不到它正在寻找的函数的这种特殊情况是需要填补的最常见的情况之一。</p>
<div class="body-img landscape"><div class="responsive-img image-expandable img-article-item" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Shim-and-Blob-300x194.png" data-modal-id="single-image-modal" data-modal-container-id="single-image-modal-container" data-img-caption="&quot;Very simple MS paint diagram showing where a shim is needed.&quot;">
 
<figure> <picture>  <source media="(min-width: 1024px)" sizes="1500px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Shim-and-Blob-300x194.png?q=50&amp;fit=crop&amp;w=1500&amp;dpr=1.5"/> <source media="(min-width: 768px)" sizes="943px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Shim-and-Blob-300x194.png?q=50&amp;fit=crop&amp;w=943&amp;dpr=1.5"/> <source media="(min-width: 481px)" sizes="767px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Shim-and-Blob-300x194.png?q=50&amp;fit=crop&amp;w=767&amp;dpr=1.5"/> <source media="(min-width: 0px)" sizes="480px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Shim-and-Blob-300x194.png?q=50&amp;fit=crop&amp;w=480&amp;dpr=1.5"/> <img class="lazyload" alt="" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Shim-and-Blob-300x194.png" src="../Images/652f069a60db476dadbeb83b17627a3c.png" data-original-src="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Shim-and-Blob-300x194.png"/> </picture> <figcaption class="body-img-caption">Very simple MS paint diagram showing where a shim is needed.</figcaption> </figure> </div>


 </div>


<p>也许用一个关于OnePlus 3T的假设例子会更有意义一些。我们将使用OxygenOS和一加相机创建一个示例。如果我们为OnePlus 3T使用从OxygenOS牛轧糖中获取的相机斑点来构建基于AOSP的牛轧糖rom，我们可能会遇到问题。这是因为camera BLOBs(最初由OEM编译)将能够在OxygenOS中引用它需要的所有函数，但是由于编译的AOSP ROM可能没有这些函数或者可能以不同的名称编译了它们(从而导致函数符号之间的不匹配)，所以将会有错误。这可以通过在AOSP ROM中创建一个名为BLOB期望的新函数来解决——我们的shim。</p>

<p>编程上下文中的符号用于引用代码中的特定函数。符号是必要的，因为在编辑代码时函数的位置会改变，所以为了避免硬编码对函数的引用，编译器创建了一个符号表，其他函数可以使用它来始终引用正确的函数。当你在编译前改变一个函数的名字时，它的符号也会改变，所以基本上OEM在编译前对相机HAL源代码的任何改变都需要开发者创建一个新的填充程序。</p>
<div class="body-img landscape"><div class="responsive-img image-expandable img-article-item" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Symbol-Table-with-Hopper.png" data-modal-id="single-image-modal" data-modal-container-id="single-image-modal-container" data-img-caption="&quot;Viewing a Symbol Table with Hopper. Source: &lt;a href=\&quot;https:\/\/www.apriorit.com\/dev-blog\/363-how-to-reverse-engineer-os-x-and-ios-software\&quot;&gt;Apriorit&lt;\/a&gt;&quot;">
 
<figure> <picture>  <source media="(min-width: 1024px)" sizes="1500px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Symbol-Table-with-Hopper.png?q=50&amp;fit=crop&amp;w=1500&amp;dpr=1.5"/> <source media="(min-width: 768px)" sizes="943px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Symbol-Table-with-Hopper.png?q=50&amp;fit=crop&amp;w=943&amp;dpr=1.5"/> <source media="(min-width: 481px)" sizes="767px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Symbol-Table-with-Hopper.png?q=50&amp;fit=crop&amp;w=767&amp;dpr=1.5"/> <source media="(min-width: 0px)" sizes="480px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Symbol-Table-with-Hopper.png?q=50&amp;fit=crop&amp;w=480&amp;dpr=1.5"/> <img class="lazyload" alt="" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Symbol-Table-with-Hopper.png" src="../Images/1eac01e9ebf9658a87d8ca47cf40d8d3.png" data-original-src="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Symbol-Table-with-Hopper.png"/> </picture> <figcaption class="body-img-caption">Viewing a Symbol Table with Hopper. Source: <a href="https://www.apriorit.com/dev-blog/363-how-to-reverse-engineer-os-x-and-ios-software">Apriorit</a></figcaption> </figure> </div>


 </div>


<p>到目前为止，我们提供的解释听起来好像创建垫片很容易。在这里或那里更改几个函数名听起来并不太难，对吗？要是有那么简单就好了。shims的现实不仅仅包括函数重命名。我们采访了XDA公认的开发人员Sultanxda，他能够为我们提供一个更困难的垫片的例子。</p>

<hr/>
<p class="ad-even"> </p>


<h2 id="shimming---not-as-easy-as-it-sounds">匀场-不像听起来那么简单</h2>
<p>对于那些不熟悉OnePlus 3T的人来说，前置摄像头最初在AOSP的定制rom上相当糟糕。首先，试图拍摄任何超过800万像素的照片都会导致崩溃。在试图解决这个问题的过程中，Sultanxda制作了几个<a href="https://github.com/sultanxda/android_device_oneplus_oneplus3/commits/cm-14.1-sultan/camera/camera_shim.cpp">垫片</a>来让OnePlus 3T前置摄像头正常工作。</p>

<h3 id="shim-1---changing-the-camera-package-name">Shim #1 -更改相机包名称</h3>
<p>为了防止每当用户拍摄超过800万像素的照片时前置摄像头崩溃，Sultanxda强制摄像头HAL将所有摄像头识别为一加摄像头。这样做是因为一加决定为某些应用程序(<code>isOnePlusCamera</code>、<code>isFacebookCamera</code>等)提供一个助手功能。)因为某种原因。Sultanxda通过调整相机HAL来解决这个问题，因此它指向一个新的函数，该函数总是返回“true ”,就好像用户正在使用一加相机一样——即使他们没有使用。</p>

<h3 id="shim-2---disable-quadracfa">垫片#2 -禁用QuadraCfa</h3>
<p>对于他的下一个垫片，他必须禁用QuadraCfa，这可能是与相机相关的高通专有技术。我们说大概是因为我自己和Sultanxda都不确定QuadraCfa是什么，但Sultanxda确实知道它在启用时会破坏前置摄像头。</p>

<p>他观察到QuadraCfa会以某种方式实现自我，但他不确定它为什么或如何做到这一点。解决这个问题需要他进行非常规的修改。在常规填补中，填补函数在被编译时提供斑点正在寻找的缺失符号。在这种情况下，BLOB已经有了它需要的符号——这些符号可能代表了启动QuadraCfa的函数。</p>
<div class="body-img landscape"><div class="responsive-img image-expandable img-article-item" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Bless-Hex-Editor-300x217.png" data-modal-id="single-image-modal" data-modal-container-id="single-image-modal-container" data-img-caption="&quot;Bless Hex Editor. The program Sultanxda used.&quot;">
 
<figure> <picture>  <source media="(min-width: 1024px)" sizes="1500px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Bless-Hex-Editor-300x217.png?q=50&amp;fit=crop&amp;w=1500&amp;dpr=1.5"/> <source media="(min-width: 768px)" sizes="943px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Bless-Hex-Editor-300x217.png?q=50&amp;fit=crop&amp;w=943&amp;dpr=1.5"/> <source media="(min-width: 481px)" sizes="767px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Bless-Hex-Editor-300x217.png?q=50&amp;fit=crop&amp;w=767&amp;dpr=1.5"/> <source media="(min-width: 0px)" sizes="480px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Bless-Hex-Editor-300x217.png?q=50&amp;fit=crop&amp;w=480&amp;dpr=1.5"/> <img class="lazyload" alt="" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Bless-Hex-Editor-300x217.png" src="../Images/a27752f9d66f377955ba00e10591250a.png" data-original-src="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/09/Bless-Hex-Editor-300x217.png"/> </picture> <figcaption class="body-img-caption">Bless Hex Editor. The program Sultanxda used.</figcaption> </figure> </div>


 </div>


<p>因此，他需要覆盖照相机HAL使用的符号，本质上，使它们“丢失”,这样<i>他的</i>垫片将提供那些“丢失”的符号。唯一的方法就是通过<i>的十六进制编辑相机本身</i>。十六进制编辑基本上是通过二进制数据形式的一堆无组织的胡言乱语来寻找大海捞针——你想要编辑的函数或字符串。</p>

<p>十六进制编辑一个函数比十六进制编辑一个字符串要困难得多，但幸运的是，Sultanxda能够避免十六进制编辑QuadraCfa后面的函数，而是通过用<a href="https://github.com/sultanxda/android_device_oneplus_oneplus3/blob/ffa7f74fec608419a70e1c5a9213e2d2e92ce1b0/extract-files.sh#L62">十六进制编辑符号名来使那些符号</a>无效。</p>

<h3 id="shim-3---bright-light-crash-fix">垫片#3 -强光崩溃修复</h3>
<p>接下来，Sultanxda发现，在明亮的光线条件下从前置摄像头拍照会导致摄像头崩溃。为了在自己的设备上重现这个bug，Sultanxda竟然<em> <strong>打开了他的OnePlus One的手电筒功能，将光线照射在OnePlus 3T的前置摄像头</strong> </em>前面，以便使其崩溃并产生可用的日志！一旦他发现是什么功能导致了崩溃，他就创建了一个垫片来强制设备对前置摄像头始终使用弱光模式。</p>

<h3 id="shim-4---low-resolution-front-facing-camera-pictures">Shim #4 -低分辨率前置摄像头图片</h3>
<p>在用之前的垫片修复了强光崩溃后，Sultanxda发现了另一个错误，它实际上是由该垫片直接导致的:低分辨率的前置摄像头图片。不是以用户要求的分辨率(例如16MP)拍摄照片，而是以4MP拍摄结果照片。</p>

<p>解决这个问题需要他填充函数<code>handleSuperResolution</code>和<code>isSuperResolution</code>以总是返回true，但只有当前置摄像头处于活动状态时(因为否则，当从后置传感器拍照时，摄像头会崩溃)。</p>

<hr/>
<p class="ad-odd"> </p>


<h2 id="lesson-learned---shimming-can-be-hard"><b>经验教训——填隙可能很难</b></h2>
<p>Sultanxda承认，他为让OnePlus 3T前置摄像头工作而必须创建的垫片并不代表你典型的垫片例子。考虑到它的复杂性和对BLOB本身进行十六进制编辑的罕见必要性，他对自己的shim相当自豪。但是这个例子只是为了说明让相机硬件在某些设备上工作是多么困难。</p>

<blockquote>
<p>愿你的相机垫片冒险没有我的痛苦。-苏丹xda</p>
 </blockquote>
<p>日志、日志和更多日志。如果没有一致的方法来重现崩溃，并且没有日志，开发人员几乎没有希望找到问题的根源。即使他们找到了问题的原因，也不总是简单的解决方法。找到并消灭这些漏洞的整个过程可能需要几天或几周的时间，这也是为什么在AOSP rom上安装摄像头是一项比较困难的任务。</p>

<p>如果你的设备有一个AOSP ROM移植到它与功能齐全的硬件，希望，你可以开始欣赏的斗争，那些开发商可能已经经历了，以给你带来这些功能。感谢他们的工作，因为这不容易。这是大量的工作，绝大多数用户甚至不会注意到，因为我们论坛上有才华的开发人员正在处理Android的许多看不见的部分。</p>

<p>我们要特别感谢Sultanxda在这篇文章的写作过程中提出的许多建议。</p>

 </div>


</div>    
</body>
</html>