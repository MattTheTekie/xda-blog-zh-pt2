<html>
<head>
<title>How EAS helps make the Google Pixel the fastest Android phone</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>EAS如何帮助谷歌Pixel成为最快的安卓手机</h1>
<blockquote>原文：<a href="https://www.xda-developers.com/google-pixel-fastest-android-phone-eas/#0001-01-01">https://www.xda-developers.com/google-pixel-fastest-android-phone-eas/#0001-01-01</a></blockquote><div><div class="content-block-regular">
<p/><p>很久以前，当Linux只是Linus Torvalds头脑中的一个想法时，CPU是单核实体，它需要大量的能量，而功率却很小。第一款商用处理器Intel 4004在单核上运行的时钟频率为740kHz。当时，不需要加载调度程序。负载调度是为双核“庞然大物”保留的，比如几十年后出现的IBM Power 4。这些内核的运行速度只有1.1GHz到1.9GHz，需要程序和系统来正确利用这些内核。我们如何从这些机器发展到利用多核的软件算法？您可能以前在我们的论坛上听说过节能调度(EAS)。这也是谷歌Pixel智能手机表现如此出色的部分原因。EAS有什么了不起的，我们是如何走到这一步的？在解释这一点之前，我们需要谈谈Linux负载调度程序。</p>

 
<hr/>


<h2 id="the-evolution-of-the-linux-load-schedulers">Linux负载调度程序的发展</h2>
<h3 id="round-robin-scheduling">循环调度</h3><div class="body-img portrait"><div class="responsive-img image-expandable img-article-item-portrait" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/08/RoundRobin-198x300.jpg" data-modal-id="single-image-modal" data-modal-container-id="single-image-modal-container" data-img-caption="&quot;Round Robin Processing. Source: Wikipedia&quot;">
 
<figure> <picture>  <source media="(min-width: 1024px)" sizes="750px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/08/RoundRobin-198x300.jpg?q=50&amp;fit=crop&amp;dpr=1.5"/> <source media="(min-width: 768px)" sizes="750px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/08/RoundRobin-198x300.jpg?q=50&amp;fit=crop&amp;dpr=1.5"/> <source media="(min-width: 481px)" sizes="600px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/08/RoundRobin-198x300.jpg?q=50&amp;fit=crop&amp;dpr=1.5"/> <source media="(min-width: 0px)" sizes="360px" data-srcset="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/08/RoundRobin-198x300.jpg?q=50&amp;fit=crop&amp;dpr=1.5"/> <img class="lazyload" alt="" data-img-url="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/08/RoundRobin-198x300.jpg" src="../Images/40c93baf2d3d43469e992e7b1de35c2f.png" data-original-src="https://static1.xdaimages.com/wordpress/wp-content/uploads/2017/08/RoundRobin-198x300.jpg"/> </picture> <figcaption class="body-img-caption">Round Robin Processing. Source: Wikipedia</figcaption> </figure> </div>


 </div>


<p>循环处理是一个易于解释和理解的简单概念，更易于理解其缺点。循环调度使用时间片为每个进程分配时间。假设我们的计算机上运行着四个进程。</p>

<ul> <li>过程</li> <li>过程</li> <li>过程</li> <li>处理过的</li> </ul>

<p>现在，让我们做循环调度程序的工作。在进入下一个进程之前，我们将为每个进程分配100毫秒(时间片)。这意味着进程A可能需要100毫秒来完成它的处理，然后它转到进程B，依此类推。如果一个应用程序的工作需要250毫秒来完成，它将需要经历这个过程3次才能完成它的工作！现在，在不同的内核之间进行扩展，以便将进程A和进程B分配给内核1，将进程C和进程D分配给内核2。取而代之的是O(n)调度(类似于循环调度，但使用历元并允许动态分配时间)，然后是O(1)调度(最小化开销，无限制的进程支持)，最后是完全公平调度(CFS)。CFS在2007年10月被合并到Linux内核版本2.6.23中。自那以后，它已经被彻底改造过，并且仍然是Linux系统中的默认调度程序。</p>

<h3 id="completely-fair-scheduler">完全公平调度程序</h3>
<p>完全公平调度器从Android诞生之初就存在了，并且在非big上使用。小装置。它使用智能算法来确定处理顺序、时间分配等。这是一个被称为“加权公平排队”的调度算法的工作实现的例子这主要集中在为系统进程和机器上运行的其他高优先级进程提供优先级。如果它运行在一个大的。小设备，所有内核将被视为平等的。这很糟糕，因为低功耗内核可能被迫运行密集型应用，甚至更糟的是，可能会出现相反的情况。用于听音乐的解码可能在大核上完成，例如，增加了不必要的功耗。这就是为什么我们需要一个新的调度程序。LITTLE是一款能够有效识别和利用内核差异的处理器。这就是异构多处理(HMP)的用武之地，它是大多数Android手机现在运行的标准负载调度程序。</p>

<h3 id="heterogeneous-multi-processing">异构多处理</h3>
<p>这是任何大型应用程序的标准负载调度程序。除了谷歌Pixel，近年来发布的设备很少。HMP利用大。小架构，将低优先级、不太密集的工作分配给功耗较低的小内核。HMP是“安全的”,它知道什么应该去大核，什么应该去小核，不会出错。它工作正常，并且在开发端设置起来比EAS之类的东西需要的精力少得多，我们稍后会谈到EAS。HMP只是CFS的一个扩展，使其具有功耗意识。</p>

<p>HMP既不猜测，也不预测未来的进程。这很好，但这也是为什么该设备不能像运行e as的设备一样流畅，也是为什么它消耗更多的电池。最后，这让我们想到了节能调度(EAS ),我坚信随着越来越多的OEM厂商采用它，这是ROM和内核开发的未来。</p>

<h3 id="energy-aware-scheduling">节能调度</h3>
<p>节能调度(EAS)是用户在我们的论坛上谈论的下一件大事。如果你使用OnePlus 3(或者显然是谷歌Pixel ),你肯定在论坛上听说过它。它随着高通骁龙845进入主流，所以如果你有一台这样的设备，你就已经有了一部支持EAS的智能手机。内核形式的ea如<a href="https://forum.xda-developers.com/oneplus-3/oneplus-3--3t-cross-device-development/renderzenith-op3-t3803706"> RenderZenith </a>和rom如<a href="https://forum.xda-developers.com/oneplus-3/oneplus-3--3t-cross-device-development/rom-kernel-vertexos-blazar-zenith-kernel-t3571781"> VertexOS </a>和<a href="https://forum.xda-developers.com/oneplus-3/oneplus-3--3t-cross-device-development/rom-pure-fusion-os-t3654996"> PureFusion </a>在OnePlus 3的全盛时期席卷了论坛。当然，谷歌Pixel也配有EAS。有了延长电池寿命和更好性能的承诺，还有什么问题呢？</p>

<p>节能调度并不简单，因为它不能通用于CFS或HMP等所有设备。EAS需要了解运行它的处理器，基于能量模型。这些能源模型是由工程师团队不断测试和工作，以提供最佳性能。由于骁龙820和821基本相同，OnePlus 3上的定制内核使用了谷歌像素能量模型。配备骁龙845的设备可以使用EAS，OnePlus 6在某种程度上也是如此。它不像谷歌Pixel设备那样经过调整，但它完成了任务。以下是一个例子，说明尽管OnePlus 6拥有更好的EAS处理器，但Pixel 2 XL仍然在流畅度上击败了它。这两张图片都来自我们对OnePlus 6的<a href="https://www.xda-developers.com/oneplus-6-speed-gaming-review/">速度导向评测</a>。</p>





<p>如果你理解这些图表有困难，你可以看看下面的图片作为指导。超过绿线的任何东西都表示丢帧，在最糟糕的情况下，会出现明显的口吃。</p>



<p>OnePlus 6的EAS实现很有趣，因为它似乎不是一个完全成熟的实现，不像你在具有相同SoC的Google Pixel上看到的那样。调度器可调参数也没有多大意义，所以这可能解释了为什么它不如您预期的那样高效。它在功耗方面非常保守，系统优先考虑低功耗内核来完成大部分工作。</p>

<p>可调参数只是传递给CPU调控器的一组参数，它改变调控器在频率方面对某些情况的反应。然后，调度程序决定将任务放在不同处理器的什么位置。OnePlus 6的可调参数设置为优先处理低功耗核心上的工作。谷歌Pixel 2拥有巨大的输入提升能力，使所有8个内核始终保持在线，这也于事无补。谷歌还使用了一个<a href="https://source.android.com/devices/tech/debug/jank_jitter#interrupt">中断平衡器</a>，它有助于消除丢帧并提高性能。</p>

<p>那么EAS是如何工作的呢？为什么只有在特定条件下才如此高效？</p>

<p>能量感知调度引入了使用能量模型的需要，并且如上所述，需要大量的测试和工作来使其完美。EAS试图统一内核的三个不同的核心部分，它们都独立地起作用，而能量模型有助于统一它们。</p>

<ul> <li>Linux调度程序(CFS，如上所述)</li> <li>Linux指南</li> <li>Linux cpufreq</li> </ul>

<p>将所有3个部分统一在调度程序下，并一起计算它们，有可能节省能量，因为一起计算它们可以使它们尽可能高效。CPUIdle试图决定何时CPU应该进入空闲模式，而CPUFreq试图决定何时提升或降低CPU。这两个模块的主要目标都是节能。不仅如此，它还将进程分为四个组，顶层应用、系统后台、前台和后台。要处理的任务被放入这些类别中的一个，然后该类别被赋予CPU能力，工作被委托给不同的CPU核心。top-app是完成优先级最高的，其次是前台，后台，然后是系统后台。从技术上讲，后台与系统后台具有相同的优先级，但是系统后台通常也可以访问更多的小内核。实际上，节能调度是将Linux内核的核心部分整合到一个进程中。</p>

<p>当唤醒设备时，EAS将选择处于最浅空闲状态的内核，从而将唤醒设备所需的能量降至最低。这有助于降低使用设备时所需的功率，因为如果不需要，它不会唤醒大型集群。负载跟踪也是EAS的一个极其重要的部分，有两个选项。“逐实体负载跟踪”(PELT)通常用于负载跟踪，该信息然后用于决定频率以及如何在CPU上分配任务。“窗口辅助负载跟踪”(WALT)也可以使用，这就是谷歌像素上使用的。我们论坛上的很多EAS ROMs，比如VertexOS，都选择使用WALT。很多rom会发布两个版本的内核，分别是WALT或者PELT，所以由用户自己决定。WALT更具突发性，CPU频率达到高峰，而PELT则试图保持更高的一致性。负载跟踪器实际上并不影响CPU频率，它只是告诉系统CPU的使用情况。更高的CPU使用率需要更高的频率，因此PELT的一个一贯特征是它会导致CPU频率缓慢上升或下降。PELT确实倾向于更高的CPU负载报告，因此它可能以更高的电池成本提供更高的性能。然而，现在没有人能真正说出哪个负载跟踪系统更好，因为两种负载跟踪方法都在不断地修补和改进。</p>

<p>无论哪种方式，很明显，不管使用哪种负载跟踪方法，效率都会提高。不是在任何处理器上处理任务，而是分析任务并估计运行任务所需的能量。这种巧妙的任务放置意味着任务以更高效的方式完成，同时也使系统整体更快。EAS旨在以最小的功耗获得最流畅的用户界面。这就是schedtune等其他外部组件发挥作用的地方。</p>

<p>Schedtune在每个cgroup中由两个可调参数定义，这两个可调参数确保对要完成的任务进行更精细的控制。它不仅控制任务在多个CPU上的分布，还控制感知的负载是否应该增加，以确保时间敏感的任务更快地完成。这样，用户使用的前台应用程序和服务就不会变慢，也不会导致不必要的性能问题。</p>

<p>虽然节能调度是下一件大事，但也可以说它已经到来，而且已经有一段时间了。随着越来越多的设备采用节能调度成为主流，移动处理效率的新时代已经到来。</p>
<p class="ad-odd"> </p>


<h2 id="the-pros-and-cons-of-round-robin-cfs-hmp-and-eas">循环赛、CFS、HMP和EAS的利弊</h2>
<p>虽然我的图形技能很一般，但我还是拼凑了一张图片，它应该总结了这些调度程序的优缺点。</p>



<hr/>

<p><em>我要特别感谢XDA公认的贡献者<a href="https://forum.xda-developers.com/member.php?u=5060769"> Mostafa Wael </a>，他对EAS各个方面的解释极大地帮助了这篇文章的完成。我也要感谢XDA认可的开发者<a href="https://forum.xda-developers.com/member.php?u=6745491">乔舒斯</a>，XDA认可的开发者<a href="https://forum.xda-developers.com/member.php?u=5438598"> RenderBroken </a>和<a href="https://forum.xda-developers.com/u11/development/kernel-kirisakura-eas-0-7-energy-aware-t3647471/post73189268">穆斯塔法·瓦尔对EAS </a>的评论。对于那些对EAS相关器件感兴趣的人来说，Linaro有很多关于EAS的文档可以阅读。</em></p>

 </div>


</div>    
</body>
</html>