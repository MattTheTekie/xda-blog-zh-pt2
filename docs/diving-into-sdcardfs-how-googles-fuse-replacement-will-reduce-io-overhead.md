# 深入 SDCardFS:Google 的保险丝更换将如何降低 I/O 开销

> 原文：<https://www.xda-developers.com/diving-into-sdcardfs-how-googles-fuse-replacement-will-reduce-io-overhead/>

几个月前，谷歌在 Linux 内核的 AOSP 官方分支中添加了一个名为“ **SDCardFS** 的东西。当时，这一举动只被[的一些内核开发者](https://twitter.com/arter97/status/712615865800220672?lang=en)注意到，但在其他方面却被大多数用户忽略了。考虑到大多数用户，包括我自己，并不真正知道 Android 操作系统及其内核下发生了什么，这并不奇怪。

然而，最近一集的 *[Android 开发者后台](https://androidbackstage.blogspot.com/)* 播客重新引起了人们对这个话题的兴趣。该播客由 Chet Haase(谷歌高级软件工程师)主持，探讨了内核最近和即将发生的变化。在节目中有一位在 Android 团队工作的 Linux 内核开发人员——Rom le marchand。两人主要讨论了为适应 A/B 更新所做的改变，但在这一集的最后 5 分钟，勒马尔钱德先生谈到了他的团队正在进行的“下一件大事”——**SDCardFS**。

我必须承认，我是听了这个播客才知道 SDCardFS 的存在的。当然，我不是唯一对这个话题感兴趣的人，正如最近 Reddit 上的一个帖子所显示的。然而，我对播客中提供的基本解释并不满意，为了消除一些正在传播的错误信息，我自己做了一些研究，并与一些具有相关知识的专家进行了交谈。

非常感谢软件开发人员迈克尔·科瓦尔茨克为本文贡献他的知识，并花时间回答我的问题。

* * *

## “外在”其实是内在的

马上，我们必须澄清一些误解——否则文章的其余部分将会非常混乱。讨论 SD 卡和安卓手机的历史很有帮助。

在 Android 手机的早期，几乎所有设备都依赖于使用 microSD 卡进行存储。这是因为当时的手机内部存储容量很小。然而，用于存储应用程序的 SD 卡通常无法提供出色的用户体验，至少与内部闪存读取/写入数据的速度相比是如此。因此，越来越多地使用 SD 卡进行外部数据存储成为了谷歌的用户体验问题。

由于 SD 卡作为外部存储设备的早期扩散，Android 的存储命名约定基于这样一个事实，即每个设备都有一个实际的物理 microSD 卡插槽。但是，即使在不包含 SD 卡插槽的设备上,/sdcard 标签仍然用于指向实际的内部存储芯片。更令人困惑的是，利用物理 SD 卡和高容量存储芯片进行存储的设备通常会根据 SD 卡来命名它们的分区。例如，在这些设备中,/sdcard 挂载点指的是实际的内部存储芯片，而/storage/sdcard1 则指的是物理外部卡。

因此，尽管 microSD 卡实际上被认为是外部存储器，但命名惯例导致“SD card”在物理卡的任何实际使用之后仍然存在。这种与存储的混淆也给应用程序开发人员带来了一些麻烦，因为应用程序数据及其媒体在两个分区之间是分离的。

早期内部存储芯片的低存储空间导致用户沮丧地发现他们不能再安装应用程序(由于/data 分区已满)。与此同时，他们更大容量的 microSD 卡被降级为只能存储媒体(如照片、音乐和电影)。以前浏览我们论坛的用户可能还记得这些名字:Link2SD 和 Apps2SD。这些是(根)解决方案，使用户能够将其应用程序和数据全部安装在物理 SD 卡上。但是这些都不是完美的解决方案，所以谷歌不得不介入。

众所周知，谷歌很早就拔掉了 SD 卡的插头。Nexus One 仍然是唯一一款配有 microSD 卡插槽的 Nexus 设备(而且将永远如此，因为 Nexus 品牌实际上已经死亡)。有了 Nexus S，现在只有一个统一的分区来存储所有应用程序数据和媒体，即/data 分区。曾经被称为/sdcard 挂载点现在只是指位于数据分区- /data/media/0 中的虚拟文件系统(在下面讨论的 **FUSE** 协议下实现)。

为了保持兼容性和减少混乱，谷歌仍然使用这个现在虚拟的“sdcard”分区来保存媒体。但是现在这个“sdcard”虚拟分区实际上位于/data 中，其中存储的任何内容都将计入内部存储芯片的存储空间。因此，原始设备制造商需要考虑将多少空间分配给应用程序(/data)还是分配给介质(/data/media)。

 <picture>![](img/32639251f9920512e68f7cd457c0cd99.png)</picture> 

Two Very Different "SD Cards"

谷歌希望制造商效仿他们的做法，放弃 SD 卡。幸运的是，随着时间的推移，手机制造商能够以更高的容量采购这些组件，同时保持成本效益，因此对 SD 卡的需求开始减少。但是命名约定一直存在，以减少开发人员和 OEM 不得不进行调整的工作量。目前，当我们提到“外部存储”时，我们指的是[以下两者之一](https://developer.android.com/guide/topics/data/data-storage.html#filesExternal):实际的可移动 microSD 卡或位于/data/media 中的虚拟“SD card”分区。实际上，后者*实际上是内部存储*，但谷歌的命名约定将其区分开来，因为用户可以访问这些数据(例如当插入计算机时)。

> 目前，当我们提到“外部存储”时，我们指的是[以下两者之一](https://developer.android.com/guide/topics/data/data-storage.html#filesExternal):实际的可移动 microSD 卡或位于/data/media 中的虚拟“SD card”分区。

* * *

## Android 虚拟文件系统的历史

既然“sdcard”被视为虚拟文件系统，这意味着它可以被格式化为 Google 想要的任何文件系统。从 Nexus S 和 Android 2.3 开始，谷歌选择将“sdcard”格式化为 VFAT(虚拟脂肪)。这一举措在当时是有意义的，因为安装 VFAT 将允许几乎任何电脑访问你手机上存储的数据。然而，这个初始实现有两个主要问题。

第一个主要关系到最终用户(您)。为了将设备连接到电脑，您需要使用 USB 大容量存储模式来传输数据。然而，这需要 Android 设备在计算机可以访问数据之前卸载虚拟分区。如果用户想在接通电源的情况下使用他们的设备，许多东西会显示为不可用。

媒体传输协议 (MTP)的引入解决了第一个问题。接通电源后，您的电脑会将您的设备视为“媒体储存”设备。它会从你的手机上请求一份文件列表，MTP 会返回一份电脑可以从手机上下载的文件列表。当请求删除某个文件时，MTP 会发送一条命令，将所请求的文件从存储中删除。与实际安装“SD 卡”的 USB 大容量存储模式不同，MTP 允许用户在插电时继续使用他们的设备。此外，Android 手机上的文件系统对于计算机识别设备上的文件不再重要。

其次，VFAT 没有提供谷歌需要的那种强大的权限管理。早期，许多应用程序开发人员将“sdcard”视为应用程序数据的转储地，没有统一的文件存储位置。许多应用程序会简单地用它的应用程序名称创建一个文件夹，并在那里存储它的文件。

当时几乎每个应用程序都需要 [WRITE_EXTERNAL_STORAGE](https://developer.android.com/reference/android/Manifest.permission.html#WRITE_EXTERNAL_STORAGE) 许可才能将应用程序文件写入外部存储器。然而，更麻烦的是，几乎每个应用程序都需要 [READ_EXTERNAL_STORAGE](https://developer.android.com/reference/android/Manifest.permission.html#READ_EXTERNAL_STORAGE) 权限——只是为了读取它们自己的数据文件！这意味着应用程序可以轻松地访问存储在外部存储设备上任何地方的数据，而且这种权限通常由用户授予，因为这是许多应用程序运行所必需的。

谷歌显然认为这有问题。权限管理背后的整个想法是分离应用程序可以访问和不可以访问的内容。如果几乎每个应用程序都被授予读取潜在敏感用户数据的权限，那么这种权限就毫无意义。因此，谷歌决定他们需要一种新的方法。这就是导火索的由来。

* * *

## 用户空间中的文件系统(FUSE)

从 Android 4.4 开始，谷歌决定不再将虚拟的“sdcard”分区挂载为 VFAT。相反，Google 开始使用 FUSE 在“sdcard”虚拟分区上模拟 FAT32。随着 sdcard 程序调用 [FUSE 来模拟 FAT-on-sdcard 风格的目录权限](http://androidxref.com/6.0.0_r5/xref/system/core/sdcard/sdcard.c)，应用可以开始访问其存储在外部存储*上的数据，而无需任何权限*。事实上，从 API Level 19 开始，READ_EXTERNAL_STORAGE 不再需要访问位于外部存储上的文件——前提是 FUSE 守护程序创建的数据文件夹与应用的包名匹配。当一个应用程序被安装时，FUSE 将处理[合成外部存储器上文件的所有者、组和模式](https://source.android.com/devices/storage/)。

FUSE 不同于内核模块，因为它允许非特权用户编写虚拟文件系统。Google 实现 FUSE 的原因很简单——它做了他们想做的事情，并且已经被 Linux 世界很好地理解和记录。引用一位[谷歌开发者关于此事的话](https://groups.google.com/d/msg/android-platform/U-pUof6PGNo/ei3F-_2fCAAJ):

> #### “因为 FUSE 是一个很好的稳定的 API，所以在内核版本之间移动时基本上不需要任何维护工作。如果我们迁移到内核解决方案，我们将为每个稳定的内核版本维护一组补丁。”——杰夫·夏基，谷歌软件工程师

然而，越来越明显的是，FUSE 的开销在其他问题中对性能产生了影响。我就此事与开发人员迈克尔·科瓦尔茨克交谈过，他在一年前写了一篇精彩的博客文章，详细介绍了 FUSE 当前的问题。更多的技术细节可以在他的博客上阅读，但我会用更通俗的语言描述他的发现(在他的允许下)。

* * *

## 保险丝的问题是

在 Android 中，“sdcard”用户空间守护进程利用 FUSE 在启动时将/dev/fuse 挂载到模拟的外部存储目录。之后，sdcard 守护进程会轮询 FUSE 设备以获取来自内核的任何未决消息。如果你听了播客，你可能听过 Lemarchand 先生提到 FUSE 在 I/O 操作中引入开销——下面是实际情况。

> 在现实世界中，这种性能影响会影响存储在外部存储器上的任何文件。

***问题# 1——I/O 开销***

假设我们创建了一个简单的文本文件，名为“test.txt ”,并将其存储在/sdcard/test.txt 中(让我提醒您，该文件实际上是/data/media/0/test.txt，假设当前用户是设备上的主用户)。如果我们想读取(命令 cat)这个文件，我们会期望系统发出 3 个命令:打开，读取，然后关闭。事实上，正如科瓦尔茨克用 strace 演示的那样，事情就是这样发生的:

但是由于该文件位于由 sdcard 守护进程管理的外部存储器上，因此需要执行许多额外的操作。根据科瓦尔茨克先生的说法，这三个独立命令中的每一个*基本上都需要 8 个额外的步骤:*

1.  用户空间应用程序发出系统调用，该调用将由内核中的 FUSE 驱动程序处理(我们在第一个 strace 输出中看到)
2.  内核中的 FUSE 驱动程序通知用户空间守护进程(sdcard)有新的请求
3.  用户空间守护进程读取/dev/fuse
4.  用户空间守护进程解析命令并识别文件操作(例如打开)
5.  用户空间守护进程向实际的文件系统发出系统调用(EXT4)
6.  内核处理物理数据访问，并将数据发送回用户空间
7.  用户空间修改(或不修改)数据，并通过/dev/fuse 再次传递给内核
8.  内核完成最初的系统调用，并将数据移动到实际的用户空间应用程序(在我们的示例 cat 中)

对于要运行的单个 I/O 命令来说，这似乎是一笔很大的开销。你是对的。为了证明这一点，科瓦尔茨克先生尝试了两种不同的 I/O 测试:一种是复制一个大文件，另一种是复制许多小文件。他比较了 FUSE(在装载为 FAT32 的虚拟分区上)和内核(在格式化为 EXT4 的数据分区上)处理这些操作的速度，他发现 FUSE 确实造成了很大的开销。

在第一个测试中，他在两种测试条件下复制了一个 725MB 的文件。他发现 FUSE 实现传输大文件的速度**比**慢 17%。

在第二次测试中，他复制了 10，000 个文件——每个文件大小为 5kb。在这种情况下，FUSE 实现比**慢 40 秒**来复制基本上 50MBs 的数据。

在现实世界中，这种性能影响会影响存储在外部存储器上的任何文件。这意味着应用程序，如在/sdcard 上存储大文件的地图，存储大量音乐文件的音乐应用程序，相机应用程序和照片等。任何涉及外部存储的 I/O 操作都会受到 FUSE 开销的影响。但是 I/O 开销并不是 FUSE 的唯一问题。

***问题# 2——双缓存***

数据缓存对于提高数据访问性能非常重要。通过在内存中存储重要的数据，Linux 内核能够在需要时快速调用这些数据。但由于 FUSE 的实现方式，Android 存储的缓存量是所需的两倍。

正如科瓦尔茨克先生所演示的那样，一个 10MB 的文件被保存在缓存中的时间预计正好是 10MB，但是缓存的大小却增加了大约 20mb。这在 RAM 较少的设备上是个问题，因为 Linux 内核存储使用页面缓存在内存中存储数据。科瓦尔茨克先生用这种方法测试了双重缓存的问题:

1.  创建一个已知大小的文件(用于测试，10MBs)
2.  将其复制到/sdcard
3.  删除页面缓存
4.  拍摄页面缓存使用情况的快照
5.  阅读测试文件
6.  拍摄页面缓存使用的另一个快照

他发现在他的测试之前，241MBs 被内核用于页面缓存。一旦他阅读了他的测试文件，他期望看到 251MBs 用于页面缓存。相反，他发现那个内核使用了**263 MB**用于页面缓存——大约是预期的两倍**。出现这种情况的原因是，数据首先由最初发出 I/O 调用的用户应用程序(FUSE)缓存，然后由 sdcard 守护进程(EXT4 FS)缓存。**

***问题# 3——fat 32***执行不完整

使用模拟 FAT32 的 FUSE 还有另外两个问题，在 Android 社区中不太为人所知。

第一个问题涉及**不正确的时间戳**。如果你曾经传输过一个文件(比如一张照片)并注意到时间戳不正确，那是因为 Android 实现了 FUSE。这个问题[已经存在**年**T5 年了。更具体地说，这个问题涉及到 *utime()* 系统调用，它允许您更改文件的访问和修改时间。不幸的是，作为标准用户对 sdcard 守护进程的调用没有执行该系统调用的适当权限。对此有变通办法，但它们要求您](https://code.google.com/p/android/issues/detail?id=34691)[拥有根访问权限](https://forum.xda-developers.com/android/general/guide-timestamp-attributes-correct-t2960935)。

> 如果你曾经传输过一个文件(比如一张照片)并注意到时间戳不正确，那是因为 Android 实现了 FUSE。

下一个问题对于使用类似于智能 SD 卡的企业来说更令人担忧。在 FUSE 之前，应用程序制造商可以监控 [O_DIRECT 标志](https://code.google.com/p/android/issues/detail?id=67406)，以便与卡中的嵌入式微控制器进行通信。使用 FUSE，开发人员只能访问文件的缓存版本，而看不到微控制器发送的任何命令。这对于一些与增值 microSD 卡通信的企业/政府/银行应用程序来说是个问题。

* * *

## SDCardFS 的转储保险丝

一些 OEMS 很早就认识到了这些问题，并开始寻找一种内核解决方案来替代 FUSE。比如三星就开发了基于 WrapFS 的 **SDCardFS** 。这个内核解决方案就像 FUSE 一样模拟 FAT32，但是放弃了 I/O 开销、双重缓存和我上面提到的其他问题。(是的，让我重申这一点，**谷歌现在实施的这个解决方案是基于三星的工作**)。

谷歌自己终于承认了 FUSE 的缺点，这也是他们开始转向三星开发的内核 FAT32 仿真层的原因。正如 Android 开发者后台播客中提到的，该公司一直致力于在即将发布的内核版本中使 SDCardFS 可用于所有设备。你目前可以看到他们在 AOSP 的[工作进展。](https://android.googlesource.com/kernel/common.git/+/android-4.1/fs/sdcardfs/)

正如 [Google 开发人员在前面](https://groups.google.com/d/msg/android-platform/U-pUof6PGNo/ei3F-_2fCAAJ)解释的那样，实现内核解决方案的最大挑战是如何将包名映射到应用程序 ID，这是包在不需要任何权限的情况下访问外部存储中自己的数据所必需的。但这一声明是在一年前做出的，我们已经到了团队将 SDCardFS 称为他们的“下一件大事”的地步他们已经证实了[可怕的时间戳错误](https://code.google.com/p/android/issues/detail?id=18624#c128)已经修复，这要感谢远离 FUSE，所以我们可以期待看到放弃 FUSE 带来的所有变化。

* * *

## 事实核查误解

如果你已经读到这篇文章的这一步，那么到目前为止，你能跟上每一步都是值得称赞的！我想澄清我自己在写这篇文章时的几个问题:

*   SDCardFS】与实际 SD 卡无关。之所以这样命名，是因为它处理/sdcard 的 I/O 访问。你可能还记得，/sdcard 是一个过时的标签，指的是设备的“外部”存储(应用程序存储媒体的地方)。
*   SDCardFS**不是 FAT32、EXT4 或 F2FS 这样的传统文件系统**。它是一个可堆叠的包装文件系统，将命令传递给较低的仿真文件系统(在本例中，它是/sdcard 上的 FAT32)。
*   对于 MTP 来说，一切都不会改变。你将继续使用 MTP 在你的电脑上传输文件(直到谷歌找到一个更好的协议)。但至少时间戳错误会被修复！
*   如前所述，当 Google 提到“外部存储”时，他们要么是在谈论(出于所有意图和目的)internal /sdcard 虚拟 FAT32 分区，要么是在谈论实际的、物理的、可移动的 microSD 卡。术语令人困惑，但这正是我们印象深刻的。

* * *

## 结论

通过摆脱 FUSE 并实现内核 FAT32 仿真层(SDCardFS)，Google 将减少大量 I/O 开销，消除双重缓存，并解决一些与 FUSE 的 FAT32 仿真相关的模糊问题。

由于这些改变将会在内核中进行，所以它们可以在没有新版本 Android 的情况下推出。一些用户期待看到这些变化在 Android 8 中正式实现，但任何未来在 Pixel 设备上的 OTA 都有可能带来谷歌一直在努力的 Linux 内核版本 4.1。

对于你们中的一些人来说，SDCardFS 并不是一个新概念。事实上，三星设备已经使用它很多年了(毕竟是他们开发的)。自从 SDCardFS 去年在 AOSP 推出以来，一些定制 ROM 和内核开发人员已经选择在他们的工作中实现它。CyanogenMOD 一度考虑过实现它，但当用户的照片遇到问题时，就放弃了。但希望随着谷歌在这个项目上占据主导地位，所有未来设备上的 Android 用户都可以利用放弃 FUSE 带来的改进。